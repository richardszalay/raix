<?xml version="1.0" encoding="UTF-8"?><allClasses><apiPackage id="raix.interactive"><apiName>raix.interactive</apiName><apiDetail/><apiClassifier id="raix.interactive:IGrouping"><apiName>IGrouping</apiName><shortdesc>
	 Contains a list of grouped values and a key identifying the group
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.interactive:IEnumerable</apiBaseInterface><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 Contains a list of grouped values and a key identifying the group
	 </apiDesc></apiClassifierDetail><related-links><link href="" invalidHref="IEnumerable.groupBy.xml"><linktext>IEnumerable.groupBy</linktext></link></related-links><apiValue id="raix.interactive:IGrouping:raix.interactive:IGrouping:key:get"><apiName>key</apiName><shortdesc>
		 Returns the key that identifies this grouping
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Object"/></apiValueDef><apiDesc>
		 Returns the key that identifies this grouping
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.interactive:IOrderedEnumerable"><apiName>IOrderedEnumerable</apiName><shortdesc>
	 An enumerable sequence that has ordering applied to it
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.interactive:IEnumerable</apiBaseInterface><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 An enumerable sequence that has ordering applied to it
	 </apiDesc></apiClassifierDetail><apiOperation id="raix.interactive:IOrderedEnumerable:raix.interactive:IOrderedEnumerable:thenByDescending"><apiName>thenByDescending</apiName><shortdesc>
		 Adds a secondary, descending, sort condition to the IOrderedEnumerable
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An IOrderedObservable that can be enumerated or further ordered using methods 
		     available on IOrderedObservable
		 </apiDesc><apiOperationClassifier>raix.interactive:IOrderedEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>A function that retrieves the key used to order the values in the source sequence:
		     function(element : TElement) : TKey
		 </apiDesc></apiParam><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A function that compares key values. The return value should follow rules of 
		     the compareFunction in Array.sort: function(x : TKey, y : TKey) : int
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Adds a secondary, descending, sort condition to the IOrderedEnumerable
		 </apiDesc></apiOperationDetail><related-links><link href="" invalidHref="raix.interactive.IOrderedObservable.xml"><linktext>raix.interactive.IOrderedObservable</linktext></link></related-links></apiOperation><apiOperation id="raix.interactive:IOrderedEnumerable:raix.interactive:IOrderedEnumerable:thenBy"><apiName>thenBy</apiName><shortdesc>
		 Adds a secondary sort condition to the IOrderedEnumerable
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An IOrderedObservable that can be enumerated or further ordered using methods 
		     available on IOrderedObservable
		 </apiDesc><apiOperationClassifier>raix.interactive:IOrderedEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>A function that retrieves the key used to order the values in the source sequence:
		     function(element : TElement) : TKey
		 </apiDesc></apiParam><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A function that compares key values. The return value should follow rules of 
		     the compareFunction in Array.sort: function(x : TKey, y : TKey) : int
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Adds a secondary sort condition to the IOrderedEnumerable
		 </apiDesc></apiOperationDetail><related-links><link href="" invalidHref="raix.interactive.IOrderedObservable.xml"><linktext>raix.interactive.IOrderedObservable</linktext></link></related-links></apiOperation></apiClassifier><apiClassifier id="raix.interactive:IEnumerable"><apiName>IEnumerable</apiName><shortdesc>
	 Represents a collection of values which can be enumerated using foreach, but 
	 does not support random access
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive:ICancelable</apiBaseInterface><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 Represents a collection of values which can be enumerated using foreach, but 
	 does not support random access
	 </apiDesc></apiClassifierDetail><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:all"><apiName>all</apiName><shortdesc>
		 Determines if the every value in the source sequence matches a predicate 
		 function.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>true if the sequence is empty or all the values in the sequence match the predicate; 
		         false otherwise
		 </apiDesc><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>(optional) A function in the format: function(element : TElement) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Determines if the every value in the source sequence matches a predicate 
		 function.
		 
		 Uses immediate execution and stops enumerating when a negative match is found.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:any"><apiName>any</apiName><shortdesc>
		 Determines if the predicate argument function returns true for any 
		 item in the sequence.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>true if a matching value is found or if predicate is null and the
		              sequence contains any values; false otherwise
		 </apiDesc><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A function in the format: function(element : TElement) : Boolean 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Determines if the predicate argument function returns true for any 
		 item in the sequence. If no function is supplied, true will be returned 
		 if the sequence contains any values 
		 
		 Uses immediate execution and stops enumerating when a match is found. 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:average"><apiName>average</apiName><shortdesc>
		 Retrieves the average value in the sequence.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The average value of the sequence
		 </apiDesc><apiType value="Number"/></apiReturn><apiParam><apiItemName>valueSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, determines the numeric value of the element 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Retrieves the average value in the sequence. Throws an IllegalOperationError 
		 if the sequence is empty.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:concat"><apiName>concat</apiName><shortdesc>
		 Returns a new sequence that will seemlessly enumerate a second sequence after 
		 the first sequence completes
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence that contains the values from the first and second sequence, in order
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier><apiDesc>The sequence to enumerate after the first sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns a new sequence that will seemlessly enumerate a second sequence after 
		 the first sequence completes
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:contains"><apiName>contains</apiName><shortdesc>
		 Determines if the source sequence contains a specific value, optionally 
		 using an equalityComparer function.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>true if a match was found; false otherwise
		 </apiDesc><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="Object"/><apiDesc>The value to be compared
		 </apiDesc></apiParam><apiParam><apiItemName>equalityComparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A function to compare two 
		        values: function(x : TElement, y : TValue) : Boolean 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Determines if the source sequence contains a specific value, optionally 
		 using an equalityComparer function.
		 
		 Uses immediate execution and stops enumerating when a match is found
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:count"><apiName>count</apiName><shortdesc>
		 Determines the number of elements in the sequence.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The number of elements in the sequence
		 </apiDesc><apiType value="uint"/></apiReturn></apiOperationDef><apiDesc>
		 Determines the number of elements in the sequence. Uses immediate execution.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:defaultIfEmpty"><apiName>defaultIfEmpty</apiName><shortdesc>
		 Returns a new sequence that will return the given defaultValue 
		 
		 Uses deferred execution
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new IEnumerable sequence
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>defaultValue</apiItemName><apiType value="Object"/><apiData>null</apiData><apiDesc>(optional) The default value to use if the sequence is empty. 
		        If not supplied, the value will be converted from null (int = 0, boolean = false, etc)
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns a new sequence that will return the given defaultValue 
		 
		 Uses deferred execution
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:distinct"><apiName>distinct</apiName><shortdesc>
		 Returns a new sequence that only contains the unique values in the original sequence.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence that contains the distinct values of the original sequence
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>hashSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, returns a unique value for the element:
		        function(element : TElement) : THash
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns a new sequence that only contains the unique values in the original sequence.
		 
		 If the sequence contains values that are not natively comparable (String, u/int, Number, Boolean),
		 a hashSelector should be specified to return a value that is. An example of this would be to return 
		 the ID property of an entity.
		 
		 Uses deferred execution
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:elementAtOrDefault"><apiName>elementAtOrDefault</apiName><shortdesc>
		 Returns the element at the given index or a default value if 
		 the sequence does not contain that many elements.</shortdesc><prolog><asCustoms><defaultValue>The value to return if the sequence does not contain (index+1) elements
		 </defaultValue></asCustoms></prolog><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The value at index
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>index</apiItemName><apiType value="int"/><apiDesc>The zero-based index of the value to return
		 </apiDesc></apiParam><apiParam><apiItemName>defaultValue</apiItemName><apiType value="Object"/><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 Returns the element at the given index or a default value if 
		 the sequence does not contain that many elements. 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:elementAt"><apiName>elementAt</apiName><shortdesc>
		 Returns the element at the given index or throws an IllegalOperationError if 
		 the sequence does not contain that many elements.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The value at index
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>index</apiItemName><apiType value="int"/><apiDesc>The zero-based index of the value to return
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns the element at the given index or throws an IllegalOperationError if 
		 the sequence does not contain that many elements. 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:except"><apiName>except</apiName><shortdesc>
		 Returns a new sequence that contains the values in the source sequence that 
		 do not exist in the supplied sequence
		 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing the values contained in the source sequence but 
		         not the "right" sequence 
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiType value="any"/><apiDesc>The right side of the except. Can be any value that can be converted 
		              to an IEnumerable using toEnumerable
		 </apiDesc></apiParam><apiParam><apiItemName>hashSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, returns a unique value for the element:
		                     function(element : TElement) : THash
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns a new sequence that contains the values in the source sequence that 
		 do not exist in the supplied sequence
		 
		 </apiDesc></apiOperationDetail><related-links><link href="" invalidHref="raix.interactive.toEnumerable.xml"><linktext>raix.interactive.toEnumerable</linktext></link></related-links></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:filter"><apiName>filter</apiName><shortdesc>
		 Filters the source sequence based on a predicate function.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A sequence that contains values from the source sequence for which predicate returned true
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>A function that determines which elements should appear in the result:
		     function(element : TElement) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Filters the source sequence based on a predicate function. Uses deferred execution.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:firstOrDefault"><apiName>firstOrDefault</apiName><shortdesc>
		 Returns the first element in the sequence or returns a default value 
		 if the sequence is empty.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The first matching value in the sequence or defaultValue
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>defaultValue</apiItemName><apiType value="Object"/><apiData>null</apiData><apiDesc>(optional) A predicate used to match values: function(element : TElement) : Boolean
		 </apiDesc></apiParam><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 Returns the first element in the sequence or returns a default value 
		 if the sequence is empty. If predicate is supplied, the first value to match the 
		 predicate will be returned with the default value being returned if no 
		 values match the predicate
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:first"><apiName>first</apiName><shortdesc>
		 Returns the first element in the sequence or throws an IllegalOperationError 
		 if the sequence is empty.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The first value in the sequence or the first value in the sequence that matches predicate
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A predicate used to match values: function(element : TElement) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns the first element in the sequence or throws an IllegalOperationError 
		 if the sequence is empty. If predicate is supplied, the first value to match the 
		 predicate will be returned with an IllegalOperationError being thrown if no 
		 values match the predicate
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:getEnumerator"><apiName>getEnumerator</apiName><shortdesc>
		 Returns an object that can be used to enumerate through this sequence.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An IEnumerator 
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerator</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Returns an object that can be used to enumerate through this sequence. Access to this method 
		 is not generally required as IEnumerable sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:groupBy"><apiName>groupBy</apiName><shortdesc>
		 Groups elements of a sequence using a key selector function
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A sequence that has elements of type IGrouping, where each IGrouping is a sequence 
		     of values of type TElement and a key
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>Retrieves the key for a value in the sequence:
		     function(source : TSource) : TKey
		 </apiDesc></apiParam><apiParam><apiItemName>elementSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, maps the source element to an element 
		     to place in the grouping: function(source : TSource) : TElement
		 </apiDesc></apiParam><apiParam><apiItemName>keyHashSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, returns a natively comparable value
		     for a key in the sequence: function(key : TKey) : THash
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Groups elements of a sequence using a key selector function
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:groupJoin"><apiName>groupJoin</apiName><shortdesc>
		 Correlates the elements of two sequences based on keys and groups the results
		 
		 Uses immediate execution on the inner sequence, uses deferred executino on the outer (source) 
		 sequence
		 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A sequence that has elements of type TResult that are obtained by joining outer and inner
		     sequences.
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>inner</apiItemName><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier><apiDesc>The sequence to join to the first sequence. Can be any value that can be converted 
		     to an IEnumerable using toEnumerable
		 </apiDesc></apiParam><apiParam><apiItemName>outerKeySelector</apiItemName><apiType value="Function"/><apiDesc>Retrieves the key from values in the outer (source) sequence:
		     function(element : TOuterElement) : TKey 
		 </apiDesc></apiParam><apiParam><apiItemName>innerKeySelector</apiItemName><apiType value="Function"/><apiDesc>Retrieves the key from values in the inner sequence:
		     function(element : TInnerElement) : TKey
		 </apiDesc></apiParam><apiParam><apiItemName>resultSelector</apiItemName><apiType value="Function"/><apiDesc>Creates a result element from the source sequence and a sequnce of 
		     matching values from the inner sequence:
		     function(outer : TOuterElement, inner : IEnumerable.&lt;TInnerElement&gt;) : TResult
		 </apiDesc></apiParam><apiParam><apiItemName>keyHashSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) Returns a natively comparable value for a key:
		     function(key : TKey) : THash
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Correlates the elements of two sequences based on keys and groups the results
		 
		 Uses immediate execution on the inner sequence, uses deferred executino on the outer (source) 
		 sequence
		 
		 </apiDesc></apiOperationDetail><related-links><link href="" invalidHref="raix.interactive.toEnumerable.xml"><linktext>raix.interactive.toEnumerable</linktext></link></related-links></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:intersect"><apiName>intersect</apiName><shortdesc>
		 Returns a new sequence that contains only the values contained in both sequences
		 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing the unique values contained in both sequence 
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiType value="any"/><apiDesc>The right side of the intersection. Can be any value that can be converted 
		              to an IEnumerable using toEnumerable
		 </apiDesc></apiParam><apiParam><apiItemName>hashSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, returns a unique value for the element:
		                     function(element : TElement) : THash
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns a new sequence that contains only the values contained in both sequences
		 
		 </apiDesc></apiOperationDetail><related-links><link href="" invalidHref="raix.interactive.toEnumerable.xml"><linktext>raix.interactive.toEnumerable</linktext></link></related-links></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:join"><apiName>join</apiName><shortdesc>
		 Correlates the elements of two sequences based on keys.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A sequence that has elements of type TResult that are obtained by joining outer and inner
		     sequences.
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>inner</apiItemName><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier><apiDesc>The sequence to join to the first sequence. Can be any value that can be converted 
		     to an IEnumerable using toEnumerable
		 </apiDesc></apiParam><apiParam><apiItemName>outerKeySelector</apiItemName><apiType value="Function"/><apiDesc>Retrieves the key from values in the outer (source) sequence:
		     function(element : TOuterElement) : TKey 
		 </apiDesc></apiParam><apiParam><apiItemName>innerKeySelector</apiItemName><apiType value="Function"/><apiDesc>Retrieves the key from values in the inner sequence:
		     function(element : TInnerElement) : TKey
		 </apiDesc></apiParam><apiParam><apiItemName>resultSelector</apiItemName><apiType value="Function"/><apiDesc>Creates a result element from two matching elements:
		     function(outer : TOuterElement, inner : TInnerElement) : TResult
		 </apiDesc></apiParam><apiParam><apiItemName>keyHashSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) Returns a natively comparable value for a key:
		     function(key : TKey) : THash
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Correlates the elements of two sequences based on keys.
		 
		 Uses immediate execution on the inner sequence, uses deferred executino on the outer (source) 
		 sequence
		 
		 </apiDesc></apiOperationDetail><related-links><link href="" invalidHref="raix.interactive.toEnumerable.xml"><linktext>raix.interactive.toEnumerable</linktext></link></related-links></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:lastOrDefault"><apiName>lastOrDefault</apiName><shortdesc>
		 Returns the last element in the sequence or returns a default value 
		 if the sequence is empty.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The last matching value in the sequence or defaultValue
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>defaultValue</apiItemName><apiType value="Object"/><apiData>null</apiData><apiDesc>(optional) A predicate used to match values: function(element : TElement) : Boolean
		 </apiDesc></apiParam><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 Returns the last element in the sequence or returns a default value 
		 if the sequence is empty. If predicate is supplied, the last value to match the 
		 predicate will be returned with the default value being returned if no 
		 values match the predicate
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:last"><apiName>last</apiName><shortdesc>
		 Returns the last element in the sequence or throws an IllegalOperationError 
		 if the sequence is empty.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The last matching value
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A predicate used to match values: function(element : TElement) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns the last element in the sequence or throws an IllegalOperationError 
		 if the sequence is empty. If predicate is supplied, the last value to match the 
		 predicate will be returned with an IllegalOperationError being thrown if no 
		 values match the predicate
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:mapMany"><apiName>mapMany</apiName><shortdesc>
		 Maps a sequence for each value in the source sequence and concatonates the results into 
		 a single sequence.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A sequence that contains values of type TResult if resultSelector is specified, 
		     or TCollection if it is not.
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>collectionSelector</apiItemName><apiType value="Function"/><apiDesc>A function to retrieve the sequence for a value in the source sequence: 
		     function(element : TElement) : IEnumerable.&lt;TCollection&gt;
		 </apiDesc></apiParam><apiParam><apiItemName>resultSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A function that creates a result element from each source element 
		     and each of its enumerated collection values: 
		     function(element : TElement, value : TCollection) : TResult
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Maps a sequence for each value in the source sequence and concatonates the results into 
		 a single sequence. Uses deferred execution.
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:map"><apiName>map</apiName><shortdesc>
		 Projects (converts) values using a selector function.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence that contains the projected values of type TResult
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>Projects the values from the source sequence: 
		     function(element : TElement) : TResult
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Projects (converts) values using a selector function. Uses deferred execution
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:max"><apiName>max</apiName><shortdesc>
		 Retrieves the maximum element in the sequence.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The sequence element deemed to be the maximum value
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>valueSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, determines the value to be 
		        compared for each element in the sequence: function(element : TElement) : TValue
		 </apiDesc></apiParam><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, compares the value (either element 
		        value or the value returned by valueSelector): 
		        function(value : TValue) : int
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Retrieves the maximum element in the sequence. Throws an IllegalOperationError 
		 if the sequence is empty.
		 
		 If the comparison value (either the original element or the value returned by valueSelector)
		 cannot be natively ordered (ie. is not String, u/int or Number), a comparer should be supplied 
		 to compare the values
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:min"><apiName>min</apiName><shortdesc>
		 Retrieves the minimum element in the sequence.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The sequence element deemed to be the minimum value
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>valueSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, determines the value to be 
		        compared for each element in the sequence: function(element : TElement) : TValue
		 </apiDesc></apiParam><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, compares the value (either element 
		        value or the value returned by valueSelector): 
		        function(value : TValue) : int
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Retrieves the minimum element in the sequence. Throws an IllegalOperationError 
		 if the sequence is empty
		 
		 If the comparison value (either the original element or the value returned by valueSelector)
		 cannot be natively ordered (ie. is not String, u/int or Number), a comparer should be supplied 
		 to compare the values
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:ofType"><apiName>ofType</apiName><shortdesc>
		 Filters values from a sequence based on their type
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A sequence that contains only elements from the source sequence that are of type 
		     cls (or a subclass)
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>cls</apiItemName><apiType value="Class"/><apiDesc>A class on which to filter values from the source sequence.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Filters values from a sequence based on their type
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:orderByDescending"><apiName>orderByDescending</apiName><shortdesc>
		 Orders the values in the source sequence in descending order
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An IOrderedObservable that can be enumerated or further ordered using methods 
		     available on IOrderedObservable
		 </apiDesc><apiOperationClassifier>raix.interactive:IOrderedEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>A function that retrieves the key used to order the values in the source sequence:
		     function(element : TElement) : TKey
		 </apiDesc></apiParam><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A function that compares key values. The return value should follow rules of 
		     the compareFunction in Array.sort: function(x : TKey, y : TKey) : int
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Orders the values in the source sequence in descending order
		 </apiDesc></apiOperationDetail><related-links><link href="" invalidHref="raix.interactive.IOrderedObservable.xml"><linktext>raix.interactive.IOrderedObservable</linktext></link></related-links></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:orderBy"><apiName>orderBy</apiName><shortdesc>
		 Orders the values in the source sequence in ascending order
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An IOrderedObservable that can be enumerated or further ordered using methods 
		     available on IOrderedObservable
		 </apiDesc><apiOperationClassifier>raix.interactive:IOrderedEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>A function that retrieves the key used to order the values in the source sequence:
		     function(element : TElement) : TKey
		 </apiDesc></apiParam><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A function that compares key values. The return value should follow rules of 
		     the compareFunction in Array.sort: function(x : TKey, y : TKey) : int
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Orders the values in the source sequence in ascending order
		 </apiDesc></apiOperationDetail><related-links><link href="" invalidHref="raix.interactive.IOrderedObservable.xml"><linktext>raix.interactive.IOrderedObservable</linktext></link></related-links></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:reduce"><apiName>reduce</apiName><shortdesc>
		 Aggregates values in a sequence using functions passed as arguments.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The return value of resultSelector (if supplied) or the final accumulate value if 
		         resultSelector is not supplied
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>seed</apiItemName><apiType value="Object"/><apiDesc>The initial value for the accumulation
		 </apiDesc></apiParam><apiParam><apiItemName>accumulator</apiItemName><apiType value="Function"/><apiDesc>A function that returns the new accumulated value: 
		        function(accumulate : TAccumulate, element : TElement) : TAccumulate
		 </apiDesc></apiParam><apiParam><apiItemName>resultSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A function that maps the final accumulate value before being returned
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Aggregates values in a sequence using functions passed as arguments.
		 
		 Accumulates a value, starting with seed, by calling accumulator for each value in the source 
		 sequence and using the return value as the new accumulated value. When the sequence completes, 
		 the accumulated value is (optonally) mapped through resultSelector before being returned.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:repeat"><apiName>repeat</apiName><shortdesc>
		 Repeats the source sequence a specified number of times 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A sequence containing values of the same type as the source
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>(optional) The number of times to repeat the sequence. If 0, the 
		     sequence will be repeated indefinately
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Repeats the source sequence a specified number of times 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:reverse"><apiName>reverse</apiName><shortdesc>
		 Reverses the values in the source sequence
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing the reversed values of the source sequence
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Reverses the values in the source sequence
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:scan"><apiName>scan</apiName><shortdesc>
		 Returns a sequence that aggregates values using functions passed as arguments, using 
		 deferred execution and returning the values accumulated values as they are returned.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A sequence of type TAccumulate that can be enumerated
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>seed</apiItemName><apiType value="Object"/><apiDesc>The initial value for the accumulation
		 </apiDesc></apiParam><apiParam><apiItemName>accumulator</apiItemName><apiType value="Function"/><apiDesc>A function that returns the new accumulated value: 
		        function(accumulate : TAccumulate, element : TElement) : TAccumulate
		 </apiDesc></apiParam><apiParam><apiItemName>resultSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A function that maps the final accumulate value before being returned
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns a sequence that aggregates values using functions passed as arguments, using 
		 deferred execution and returning the values accumulated values as they are returned.
		 
		 Accumulates a value, starting with seed, by calling accumulator for each value in the 
		 source sequence and using the return value as the new accumulated value. Each time  
		 a new value is accumulated, the accumulated value is (optonally) mapped through 
		 resultSelector before being returned.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:sequenceEqual"><apiName>sequenceEqual</apiName><shortdesc>
		 Determines whether two sequences are equal.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>true if the sequences are of equal length and all of their values are equal
		 </apiDesc><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier><apiDesc>Ths sequence to compare to the source
		 </apiDesc></apiParam><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>A function that will determine equality between left and right values:
		     function(left : TLeft, right : TRight) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Determines whether two sequences are equal. Uses immediate execution 
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:singleOrDefault"><apiName>singleOrDefault</apiName><shortdesc>
		 Returns the first element in the sequence or throws an IllegalOperationError 
		 if the sequence does contains multiple values, but returns a default value if 
		 the sequence returns no values.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The first matching value in the sequence or defaultValue
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>defaultValue</apiItemName><apiType value="Object"/><apiData>null</apiData><apiDesc>A defaultValue to 
		 </apiDesc></apiParam><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A predicate used to match values: function(element : TElement) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns the first element in the sequence or throws an IllegalOperationError 
		 if the sequence does contains multiple values, but returns a default value if 
		 the sequence returns no values. If predicate is supplied, the first value to match 
		 the predicate will be returned with an IllegalOperationError 
		 being thrown if the sequence contains more than one match and a default value being 
		 returned if no matches are found
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:single"><apiName>single</apiName><shortdesc>
		 Returns the first element in the sequence or throws an IllegalOperationError 
		 if the sequence does not contain exactly one value.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The first value in the sequence or the first value in the sequence that matches predicate
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A predicate used to match values: function(element : TElement) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns the first element in the sequence or throws an IllegalOperationError 
		 if the sequence does not contain exactly one value. If predicate is supplied, 
		 the first value to match the predicate will be returned with an IllegalOperationError 
		 being thrown if the sequence does not contain exactly one match
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:skipLast"><apiName>skipLast</apiName><shortdesc>
		 Returns a new sequence that excludes the specified number of values from 
		 the end of the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing values of the same type as the source sequence
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of elements to skip from the end of source sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns a new sequence that excludes the specified number of values from 
		 the end of the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:skipWhile"><apiName>skipWhile</apiName><shortdesc>
		 Returns a new sequence that skips values from the source sequence 
		 until a specified predicate returns false, at which point values will be 
		 returned from the rest of sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing values of the same type as the source sequence
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>A function that determines whether values should still be skipped 
		     from the source sequence: function(element:TElement) : Boolean 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns a new sequence that skips values from the source sequence 
		 until a specified predicate returns false, at which point values will be 
		 returned from the rest of sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:skip"><apiName>skip</apiName><shortdesc>
		 Returns a new sequence that excludes the specified number of values from 
		 the start of the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing values of the same type as the source sequence
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of elements to skip from the source sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns a new sequence that excludes the specified number of values from 
		 the start of the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:sum"><apiName>sum</apiName><shortdesc>
		 Returns the total numeric value of every value in the sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The summed values of each element in the sequence
		 </apiDesc><apiType value="Number"/></apiReturn><apiParam><apiItemName>valueSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, can be used to specify the numeric 
		        value for each element in the sequence 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns the total numeric value of every value in the sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:takeLast"><apiName>takeLast</apiName><shortdesc>
		 Returns a new sequence that includes a maximum number of elements to take from 
		 the end of the first sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing values of the same type as the source sequence
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of elements to take from the end of source sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns a new sequence that includes a maximum number of elements to take from 
		 the end of the first sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:takeWhile"><apiName>takeWhile</apiName><shortdesc>
		 Returns a new sequence that includes values from the source sequence 
		 until a specified predicate returns false, at which point the sequence will end 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing values of the same type as the source sequence
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>A function that determines whether values should still be taken 
		     from the source sequence: function(element:TElement) : Boolean 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns a new sequence that includes values from the source sequence 
		 until a specified predicate returns false, at which point the sequence will end 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:take"><apiName>take</apiName><shortdesc>
		 Returns a new sequence that includes a maximum number of elements from the first sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing values of the same type as the source sequence
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of elements to take from the source sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns a new sequence that includes a maximum number of elements from the first sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:toArray"><apiName>toArray</apiName><shortdesc>
		 Retrieves an array containing all the values in the sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An Array containing values of the same type as the source sequence
		 </apiDesc><apiType value="Array"/></apiReturn></apiOperationDef><apiDesc>
		 Retrieves an array containing all the values in the sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:toDictionary"><apiName>toDictionary</apiName><shortdesc>
		 Converts the sequence to a Dictionary.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Dictionary
		 </apiDesc><apiType value="flash.utils:Dictionary"/></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>Retrieves the key for each element in the sequence
		 </apiDesc></apiParam><apiParam><apiItemName>elementSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, provides the "values"  
		     in the lookup. If not specified, the original element will be used
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Converts the sequence to a Dictionary. Uses immediate execution
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:toLookup"><apiName>toLookup</apiName><shortdesc>
		 Converts the sequence to an ILookup, which is simiular to a Dictionary with the following 
		 differences:
		 
		 
		 Supports null keys
		 Returns an empty sequence for requests for keys that do not exist
		 
		 
		 Uses immediate execution
		 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An ILookup
		 </apiDesc><apiOperationClassifier>raix.interactive:ILookup</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>Retrieves the key for each element in the sequence
		 </apiDesc></apiParam><apiParam><apiItemName>elementSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, provides the "values"  
		     in the lookup. If not specified, the original element will be used
		 </apiDesc></apiParam><apiParam><apiItemName>keyHashSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If the value returned by keySelector is not natively 
		        comparable (ie. String, u/int, Number, Boolean), keyHashSelector can be used to 
		        provide comparable values for the keys: function(key : TKey) : THash
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Converts the sequence to an ILookup, which is simiular to a Dictionary with the following 
		 differences:
		 
		 <ul>
		 <li>Supports null keys</li>
		 <li>Returns an empty sequence for requests for keys that do not exist</li>
		 </ul>
		 
		 Uses immediate execution
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:toObservable"><apiName>toObservable</apiName><shortdesc>
		 Converts the interactive sequence to an observable sequence, optionally using a scheduler 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence that contains values of the same type as the source sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>(optional) The scheduler to use to distribute the values. Defaults to 
		     Scheduler.asynchronous
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Converts the interactive sequence to an observable sequence, optionally using a scheduler 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:union"><apiName>union</apiName><shortdesc>
		 Returns a new sequence that contains the unique values across two sequences
		 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing the distinct values across both sequences 
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiType value="any"/><apiDesc>The right side of the union. Can be any value that can be converted 
		              to an IEnumerable using toEnumerable
		 </apiDesc></apiParam><apiParam><apiItemName>hashSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, returns a unique value for the element:
		                     function(element : TElement) : THash
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns a new sequence that contains the unique values across two sequences
		 
		 </apiDesc></apiOperationDetail><related-links><link href="" invalidHref="raix.interactive.toEnumerable.xml"><linktext>raix.interactive.toEnumerable</linktext></link></related-links></apiOperation><apiOperation id="raix.interactive:IEnumerable:raix.interactive:IEnumerable:zip"><apiName>zip</apiName><shortdesc>
		 Pairs values from two sequences in order and uses a selector function to project the results
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A sequence containing values of type TResult
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier><apiDesc>The sequence to pair with the left (source) sequence
		 </apiDesc></apiParam><apiParam><apiItemName>resultSelector</apiItemName><apiType value="Function"/><apiDesc>A function to map values from the left and right sequences:
		     function(left : TLeft, right : TRight) : TResult
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Pairs values from two sequences in order and uses a selector function to project the results
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="raix.interactive:ILookup"><apiName>ILookup</apiName><shortdesc>
	 Contains values grouped by keys
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.interactive:IEnumerable</apiBaseInterface><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 Contains values grouped by keys
	 </apiDesc></apiClassifierDetail><related-links><link href="" invalidHref="IEnumerable.toLookup.xml"><linktext>IEnumerable.toLookup</linktext></link></related-links><apiOperation id="raix.interactive:ILookup:raix.interactive:ILookup:containsKey"><apiName>containsKey</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>key</apiItemName><apiType value="Object"/></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:ILookup:raix.interactive:ILookup:getValues"><apiName>getValues</apiName><shortdesc>
		 Returns a sequence of values for the specified key or 
		 an empty sequence if the key has no values 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An IEnumerable sequence of values
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>key</apiItemName><apiType value="Object"/><apiDesc>The key to lookup
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns a sequence of values for the specified key or 
		 an empty sequence if the key has no values 
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="raix.interactive:Enumerable"><apiName>Enumerable</apiName><shortdesc>
	 Provides static methods that create IEnumerable sequences
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Provides static methods that create IEnumerable sequences
	 </apiDesc></apiClassifierDetail><apiOperation id="raix.interactive:Enumerable:create"><apiName>create</apiName><shortdesc>
		 Creates an enumerable sequence that uses callbacks 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An IEnumerable that contains values of type TElement 
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>moveNext</apiItemName><apiType value="Function"/><apiDesc>Moves to the next item in the sequence, returning false when no more items exist:
		     function():Boolean
		 </apiDesc></apiParam><apiParam><apiItemName>getCurrent</apiItemName><apiType value="Function"/><apiDesc>Retrieves the current value in the sequence: function():TElement
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates an enumerable sequence that uses callbacks 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:Enumerable:empty"><apiName>empty</apiName><shortdesc>
		 Creates an empty sequence
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Creates an empty sequence
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:Enumerable:fromArray"><apiName>fromArray</apiName><shortdesc>
		 Creates an enumerable sequence from an array 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An IEnumerable containing values of the same type as array
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>array</apiItemName><apiType value="Array"/><apiDesc>The array to enumerate
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates an enumerable sequence from an array 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:Enumerable:fromProxy"><apiName>fromProxy</apiName><shortdesc>
		 Creates a sequence from an enumerable proxy object
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>A sequence that will enumerate through the values in the proxy
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>proxy</apiItemName><apiType value="flash.utils:Proxy"/><apiDesc>A enumerable proxy
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence from an enumerable proxy object
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:Enumerable:generate"><apiName>generate</apiName><shortdesc>
		 Creates an enumerable sequence by calling back to functions that mainpulate its state 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An IEnumerable sequence that contains values of type TResult
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>initialState</apiItemName><apiType value="Object"/><apiDesc>The initial state value
		 </apiDesc></apiParam><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>A function called once for every value (including initialState), returns true while 
		     the sequence has more values: function(state : TState) : Boolean
		 </apiDesc></apiParam><apiParam><apiItemName>iterate</apiItemName><apiType value="Function"/><apiDesc>A function called once for every value (excluding initialState) and returns the new 
		     value for state: function(state : TState) : TState
		 </apiDesc></apiParam><apiParam><apiItemName>resultMap</apiItemName><apiType value="Function"/><apiDesc>A function that maps the current state to a value: 
		     function(state : TState) : TResult 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates an enumerable sequence by calling back to functions that mainpulate its state 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:Enumerable:range"><apiName>range</apiName><shortdesc>
		 Creates an enumerable sequence that contains the numbers in a 
		 specified range 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An IEnumerable of int values in the specified range
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>start</apiItemName><apiType value="int"/><apiDesc>The start value
		 </apiDesc></apiParam><apiParam><apiItemName>count</apiItemName><apiType value="int"/><apiDesc>The number of values to enumerate, including start
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates an enumerable sequence that contains the numbers in a 
		 specified range 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:Enumerable:repeat"><apiName>repeat</apiName><shortdesc>
		 Creates an enumerable sequence that repeats a value 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An IEnumerable containing the repeated value
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiType value="Object"/><apiDesc>The value to repeat
		 </apiDesc></apiParam><apiParam><apiItemName>count</apiItemName><apiType value="int"/><apiDesc>The number of times to repeat. A value of 0 will repeat indefinately
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates an enumerable sequence that repeats a value 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:Enumerable:value"><apiName>value</apiName><shortdesc>
		 Creates a sequence that contains a single value 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>A sequence containing the specified value
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="Object"/><apiDesc>The value to wrap in a sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence that contains a single value 
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="raix.interactive:IEnumerator"><apiName>IEnumerator</apiName><shortdesc>
	 Contains the state of an active enumeration.</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 Contains the state of an active enumeration. This interface is rarely accessed 
	 by client code as IEnumerable sequences can be used with `for each`
	 </apiDesc></apiClassifierDetail><apiOperation id="raix.interactive:IEnumerator:raix.interactive:IEnumerator:moveNext"><apiName>moveNext</apiName><shortdesc>
		 Moves to the next value in the sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>true if a new value is available; false if the end of the sequence has been reacheds
		 </apiDesc><apiType value="Boolean"/></apiReturn></apiOperationDef><apiDesc>
		 Moves to the next value in the sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.interactive:IEnumerator:raix.interactive:IEnumerator:current:get"><apiName>current</apiName><shortdesc>
		 Returns the current value in the sequence
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Object"/></apiValueDef><apiDesc>
		 Returns the current value in the sequence
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.interactive:AbsEnumerable"><apiName>AbsEnumerable</apiName><shortdesc>
	 An abstract implementation of IEnumerable.</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.interactive:IEnumerable</apiBaseInterface><apiBaseClassifier>flash.utils:Proxy</apiBaseClassifier></apiClassifierDef><apiDesc>
	 An abstract implementation of IEnumerable. This class may be made inaccessible in future revisions.
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.interactive:AbsEnumerable:AbsEnumerable"><apiName>AbsEnumerable</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.interactive:AbsEnumerable:aggregate"><apiName>aggregate</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="Object"/></apiReturn><apiParam><apiItemName>seed</apiItemName><apiType value="Object"/></apiParam><apiParam><apiItemName>accumulator</apiItemName><apiType value="Function"/></apiParam><apiParam><apiItemName>resultSelector</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:all"><apiName>all</apiName><shortdesc>
		 
		 Determines if the every value in the source sequence matches a predicate 
		 function.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>true if the sequence is empty or all the values in the sequence match the predicate; 
		         false otherwise
		 </apiDesc><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>(optional) A function in the format: function(element : TElement) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Determines if the every value in the source sequence matches a predicate 
		 function.
		 
		 Uses immediate execution and stops enumerating when a negative match is found.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:any"><apiName>any</apiName><shortdesc>
		 
		 Determines if the predicate argument function returns true for any 
		 item in the sequence.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>true if a matching value is found or if predicate is null and the
		              sequence contains any values; false otherwise
		 </apiDesc><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A function in the format: function(element : TElement) : Boolean 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Determines if the predicate argument function returns true for any 
		 item in the sequence. If no function is supplied, true will be returned 
		 if the sequence contains any values 
		 
		 Uses immediate execution and stops enumerating when a match is found. 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:average"><apiName>average</apiName><shortdesc>
		 
		 Retrieves the average value in the sequence.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The average value of the sequence
		 </apiDesc><apiType value="Number"/></apiReturn><apiParam><apiItemName>valueSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, determines the numeric value of the element 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Retrieves the average value in the sequence. Throws an IllegalOperationError 
		 if the sequence is empty.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:cancel"><apiName>cancel</apiName><shortdesc>
		 
		 Cancels the operation
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 
		 Cancels the operation
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:concat"><apiName>concat</apiName><shortdesc>
		 
		 Returns a new sequence that will seemlessly enumerate a second sequence after 
		 the first sequence completes
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence that contains the values from the first and second sequence, in order
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier><apiDesc>The sequence to enumerate after the first sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns a new sequence that will seemlessly enumerate a second sequence after 
		 the first sequence completes
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:contains"><apiName>contains</apiName><shortdesc>
		 
		 Determines if the source sequence contains a specific value, optionally 
		 using an equalityComparer function.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>true if a match was found; false otherwise
		 </apiDesc><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="Object"/><apiDesc>The value to be compared
		 </apiDesc></apiParam><apiParam><apiItemName>equalityComparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A function to compare two 
		        values: function(x : TElement, y : TValue) : Boolean 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Determines if the source sequence contains a specific value, optionally 
		 using an equalityComparer function.
		 
		 Uses immediate execution and stops enumerating when a match is found
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:count"><apiName>count</apiName><shortdesc>
		 
		 Determines the number of elements in the sequence.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The number of elements in the sequence
		 </apiDesc><apiType value="uint"/></apiReturn></apiOperationDef><apiDesc>
		 
		 Determines the number of elements in the sequence. Uses immediate execution.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:defaultIfEmpty"><apiName>defaultIfEmpty</apiName><shortdesc>
		 
		 Returns a new sequence that will return the given defaultValue 
		 
		 Uses deferred execution
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new IEnumerable sequence
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>defaultValue</apiItemName><apiType value="Object"/><apiData>null</apiData><apiDesc>(optional) The default value to use if the sequence is empty. 
		        If not supplied, the value will be converted from null (int = 0, boolean = false, etc)
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns a new sequence that will return the given defaultValue 
		 
		 Uses deferred execution
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:distinct"><apiName>distinct</apiName><shortdesc>
		 
		 Returns a new sequence that only contains the unique values in the original sequence.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence that contains the distinct values of the original sequence
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>hashSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, returns a unique value for the element:
		        function(element : TElement) : THash
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns a new sequence that only contains the unique values in the original sequence.
		 
		 If the sequence contains values that are not natively comparable (String, u/int, Number, Boolean),
		 a hashSelector should be specified to return a value that is. An example of this would be to return 
		 the ID property of an entity.
		 
		 Uses deferred execution
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:elementAtOrDefault"><apiName>elementAtOrDefault</apiName><shortdesc>
		 
		 Returns the element at the given index or a default value if 
		 the sequence does not contain that many elements.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The value at index
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>index</apiItemName><apiType value="int"/><apiDesc>The zero-based index of the value to return
		 </apiDesc></apiParam><apiParam><apiItemName>defaultValue</apiItemName><apiType value="Object"/><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 
		 Returns the element at the given index or a default value if 
		 the sequence does not contain that many elements. 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:elementAt"><apiName>elementAt</apiName><shortdesc>
		 
		 Returns the element at the given index or throws an IllegalOperationError if 
		 the sequence does not contain that many elements.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The value at index
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>index</apiItemName><apiType value="int"/><apiDesc>The zero-based index of the value to return
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns the element at the given index or throws an IllegalOperationError if 
		 the sequence does not contain that many elements. 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:except"><apiName>except</apiName><shortdesc>
		 
		 Returns a new sequence that contains the values in the source sequence that 
		 do not exist in the supplied sequence
		 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing the values contained in the source sequence but 
		         not the "right" sequence 
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiType value="any"/><apiDesc>The right side of the except. Can be any value that can be converted 
		              to an IEnumerable using toEnumerable
		 </apiDesc></apiParam><apiParam><apiItemName>hashSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, returns a unique value for the element:
		                     function(element : TElement) : THash
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns a new sequence that contains the values in the source sequence that 
		 do not exist in the supplied sequence
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:filter"><apiName>filter</apiName><shortdesc>
		 
		 Filters the source sequence based on a predicate function.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A sequence that contains values from the source sequence for which predicate returned true
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>A function that determines which elements should appear in the result:
		     function(element : TElement) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Filters the source sequence based on a predicate function. Uses deferred execution.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:firstOrDefault"><apiName>firstOrDefault</apiName><shortdesc>
		 
		 Returns the first element in the sequence or returns a default value 
		 if the sequence is empty.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The first matching value in the sequence or defaultValue
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>defaultValue</apiItemName><apiType value="Object"/><apiData>null</apiData><apiDesc>(optional) A predicate used to match values: function(element : TElement) : Boolean
		 </apiDesc></apiParam><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 
		 Returns the first element in the sequence or returns a default value 
		 if the sequence is empty. If predicate is supplied, the first value to match the 
		 predicate will be returned with the default value being returned if no 
		 values match the predicate
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:first"><apiName>first</apiName><shortdesc>
		 
		 Returns the first element in the sequence or throws an IllegalOperationError 
		 if the sequence is empty.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The first value in the sequence or the first value in the sequence that matches predicate
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A predicate used to match values: function(element : TElement) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns the first element in the sequence or throws an IllegalOperationError 
		 if the sequence is empty. If predicate is supplied, the first value to match the 
		 predicate will be returned with an IllegalOperationError being thrown if no 
		 values match the predicate
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:getEnumerator"><apiName>getEnumerator</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.interactive:IEnumerator</apiOperationClassifier></apiReturn></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:groupBy"><apiName>groupBy</apiName><shortdesc>
		 
		 Groups elements of a sequence using a key selector function
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A sequence that has elements of type IGrouping, where each IGrouping is a sequence 
		     of values of type TElement and a key
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>Retrieves the key for a value in the sequence:
		     function(source : TSource) : TKey
		 </apiDesc></apiParam><apiParam><apiItemName>elementSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, maps the source element to an element 
		     to place in the grouping: function(source : TSource) : TElement
		 </apiDesc></apiParam><apiParam><apiItemName>keyHashSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, returns a natively comparable value
		     for a key in the sequence: function(key : TKey) : THash
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Groups elements of a sequence using a key selector function
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:groupJoin"><apiName>groupJoin</apiName><shortdesc>
		 
		 Correlates the elements of two sequences based on keys and groups the results
		 
		 Uses immediate execution on the inner sequence, uses deferred executino on the outer (source) 
		 sequence
		 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A sequence that has elements of type TResult that are obtained by joining outer and inner
		     sequences.
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>inner</apiItemName><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier><apiDesc>The sequence to join to the first sequence. Can be any value that can be converted 
		     to an IEnumerable using toEnumerable
		 </apiDesc></apiParam><apiParam><apiItemName>outerKeySelector</apiItemName><apiType value="Function"/><apiDesc>Retrieves the key from values in the outer (source) sequence:
		     function(element : TOuterElement) : TKey 
		 </apiDesc></apiParam><apiParam><apiItemName>innerKeySelector</apiItemName><apiType value="Function"/><apiDesc>Retrieves the key from values in the inner sequence:
		     function(element : TInnerElement) : TKey
		 </apiDesc></apiParam><apiParam><apiItemName>resultSelector</apiItemName><apiType value="Function"/><apiDesc>Creates a result element from the source sequence and a sequnce of 
		     matching values from the inner sequence:
		     function(outer : TOuterElement, inner : IEnumerable.&lt;TInnerElement&gt;) : TResult
		 </apiDesc></apiParam><apiParam><apiItemName>keyHashSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) Returns a natively comparable value for a key:
		     function(key : TKey) : THash
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Correlates the elements of two sequences based on keys and groups the results
		 
		 Uses immediate execution on the inner sequence, uses deferred executino on the outer (source) 
		 sequence
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:intersect"><apiName>intersect</apiName><shortdesc>
		 
		 Returns a new sequence that contains only the values contained in both sequences
		 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing the unique values contained in both sequence 
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiType value="any"/><apiDesc>The right side of the intersection. Can be any value that can be converted 
		              to an IEnumerable using toEnumerable
		 </apiDesc></apiParam><apiParam><apiItemName>hashSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, returns a unique value for the element:
		                     function(element : TElement) : THash
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns a new sequence that contains only the values contained in both sequences
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:join"><apiName>join</apiName><shortdesc>
		 
		 Correlates the elements of two sequences based on keys.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A sequence that has elements of type TResult that are obtained by joining outer and inner
		     sequences.
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>inner</apiItemName><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier><apiDesc>The sequence to join to the first sequence. Can be any value that can be converted 
		     to an IEnumerable using toEnumerable
		 </apiDesc></apiParam><apiParam><apiItemName>outerKeySelector</apiItemName><apiType value="Function"/><apiDesc>Retrieves the key from values in the outer (source) sequence:
		     function(element : TOuterElement) : TKey 
		 </apiDesc></apiParam><apiParam><apiItemName>innerKeySelector</apiItemName><apiType value="Function"/><apiDesc>Retrieves the key from values in the inner sequence:
		     function(element : TInnerElement) : TKey
		 </apiDesc></apiParam><apiParam><apiItemName>resultSelector</apiItemName><apiType value="Function"/><apiDesc>Creates a result element from two matching elements:
		     function(outer : TOuterElement, inner : TInnerElement) : TResult
		 </apiDesc></apiParam><apiParam><apiItemName>keyHashSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) Returns a natively comparable value for a key:
		     function(key : TKey) : THash
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Correlates the elements of two sequences based on keys.
		 
		 Uses immediate execution on the inner sequence, uses deferred executino on the outer (source) 
		 sequence
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:lastOrDefault"><apiName>lastOrDefault</apiName><shortdesc>
		 
		 Returns the last element in the sequence or returns a default value 
		 if the sequence is empty.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The last matching value in the sequence or defaultValue
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>defaultValue</apiItemName><apiType value="Object"/><apiData>null</apiData><apiDesc>(optional) A predicate used to match values: function(element : TElement) : Boolean
		 </apiDesc></apiParam><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 
		 Returns the last element in the sequence or returns a default value 
		 if the sequence is empty. If predicate is supplied, the last value to match the 
		 predicate will be returned with the default value being returned if no 
		 values match the predicate
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:last"><apiName>last</apiName><shortdesc>
		 
		 Returns the last element in the sequence or throws an IllegalOperationError 
		 if the sequence is empty.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The last matching value
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A predicate used to match values: function(element : TElement) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns the last element in the sequence or throws an IllegalOperationError 
		 if the sequence is empty. If predicate is supplied, the last value to match the 
		 predicate will be returned with an IllegalOperationError being thrown if no 
		 values match the predicate
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:mapMany"><apiName>mapMany</apiName><shortdesc>
		 
		 Maps a sequence for each value in the source sequence and concatonates the results into 
		 a single sequence.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A sequence that contains values of type TResult if resultSelector is specified, 
		     or TCollection if it is not.
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>collectionSelector</apiItemName><apiType value="Function"/><apiDesc>A function to retrieve the sequence for a value in the source sequence: 
		     function(element : TElement) : IEnumerable.&lt;TCollection&gt;
		 </apiDesc></apiParam><apiParam><apiItemName>resultSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A function that creates a result element from each source element 
		     and each of its enumerated collection values: 
		     function(element : TElement, value : TCollection) : TResult
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Maps a sequence for each value in the source sequence and concatonates the results into 
		 a single sequence. Uses deferred execution.
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:map"><apiName>map</apiName><shortdesc>
		 
		 Projects (converts) values using a selector function.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence that contains the projected values of type TResult
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>Projects the values from the source sequence: 
		     function(element : TElement) : TResult
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Projects (converts) values using a selector function. Uses deferred execution
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:max"><apiName>max</apiName><shortdesc>
		 
		 Retrieves the maximum element in the sequence.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The sequence element deemed to be the maximum value
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>valueSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, determines the value to be 
		        compared for each element in the sequence: function(element : TElement) : TValue
		 </apiDesc></apiParam><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, compares the value (either element 
		        value or the value returned by valueSelector): 
		        function(value : TValue) : int
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Retrieves the maximum element in the sequence. Throws an IllegalOperationError 
		 if the sequence is empty.
		 
		 If the comparison value (either the original element or the value returned by valueSelector)
		 cannot be natively ordered (ie. is not String, u/int or Number), a comparer should be supplied 
		 to compare the values
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:min"><apiName>min</apiName><shortdesc>
		 
		 Retrieves the minimum element in the sequence.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The sequence element deemed to be the minimum value
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>valueSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, determines the value to be 
		        compared for each element in the sequence: function(element : TElement) : TValue
		 </apiDesc></apiParam><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, compares the value (either element 
		        value or the value returned by valueSelector): 
		        function(value : TValue) : int
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Retrieves the minimum element in the sequence. Throws an IllegalOperationError 
		 if the sequence is empty
		 
		 If the comparison value (either the original element or the value returned by valueSelector)
		 cannot be natively ordered (ie. is not String, u/int or Number), a comparer should be supplied 
		 to compare the values
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:flash_proxy:nextNameIndex"><apiName>nextNameIndex</apiName><shortdesc>
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiIsOverride/><apiReturn><apiType value="int"/></apiReturn><apiParam><apiItemName>index</apiItemName><apiType value="int"/></apiParam></apiOperationDef><apiDesc>
		 </apiDesc></apiOperationDetail><apiInheritDoc/></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:flash_proxy:nextValue"><apiName>nextValue</apiName><shortdesc>
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="flash_proxy"/><apiIsOverride/><apiReturn><apiType value="any"/></apiReturn><apiParam><apiItemName>index</apiItemName><apiType value="int"/></apiParam></apiOperationDef><apiDesc>
		 </apiDesc></apiOperationDetail><apiInheritDoc/></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:ofType"><apiName>ofType</apiName><shortdesc>
		 
		 Filters values from a sequence based on their type
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A sequence that contains only elements from the source sequence that are of type 
		     cls (or a subclass)
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>cls</apiItemName><apiType value="Class"/><apiDesc>A class on which to filter values from the source sequence.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Filters values from a sequence based on their type
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:orderByDescending"><apiName>orderByDescending</apiName><shortdesc>
		 
		 Orders the values in the source sequence in descending order
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An IOrderedObservable that can be enumerated or further ordered using methods 
		     available on IOrderedObservable
		 </apiDesc><apiOperationClassifier>raix.interactive:IOrderedEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>A function that retrieves the key used to order the values in the source sequence:
		     function(element : TElement) : TKey
		 </apiDesc></apiParam><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A function that compares key values. The return value should follow rules of 
		     the compareFunction in Array.sort: function(x : TKey, y : TKey) : int
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Orders the values in the source sequence in descending order
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:orderBy"><apiName>orderBy</apiName><shortdesc>
		 
		 Orders the values in the source sequence in ascending order
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An IOrderedObservable that can be enumerated or further ordered using methods 
		     available on IOrderedObservable
		 </apiDesc><apiOperationClassifier>raix.interactive:IOrderedEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>A function that retrieves the key used to order the values in the source sequence:
		     function(element : TElement) : TKey
		 </apiDesc></apiParam><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A function that compares key values. The return value should follow rules of 
		     the compareFunction in Array.sort: function(x : TKey, y : TKey) : int
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Orders the values in the source sequence in ascending order
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:reduce"><apiName>reduce</apiName><shortdesc>
		 
		 Aggregates values in a sequence using functions passed as arguments.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The return value of resultSelector (if supplied) or the final accumulate value if 
		         resultSelector is not supplied
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>seed</apiItemName><apiType value="Object"/><apiDesc>The initial value for the accumulation
		 </apiDesc></apiParam><apiParam><apiItemName>accumulator</apiItemName><apiType value="Function"/><apiDesc>A function that returns the new accumulated value: 
		        function(accumulate : TAccumulate, element : TElement) : TAccumulate
		 </apiDesc></apiParam><apiParam><apiItemName>resultSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A function that maps the final accumulate value before being returned
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Aggregates values in a sequence using functions passed as arguments.
		 
		 Accumulates a value, starting with seed, by calling accumulator for each value in the source 
		 sequence and using the return value as the new accumulated value. When the sequence completes, 
		 the accumulated value is (optonally) mapped through resultSelector before being returned.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:repeat"><apiName>repeat</apiName><shortdesc>
		 
		 Repeats the source sequence a specified number of times 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A sequence containing values of the same type as the source
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>(optional) The number of times to repeat the sequence. If 0, the 
		     sequence will be repeated indefinately
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Repeats the source sequence a specified number of times 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:reverse"><apiName>reverse</apiName><shortdesc>
		 
		 Reverses the values in the source sequence
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing the reversed values of the source sequence
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Reverses the values in the source sequence
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:scan"><apiName>scan</apiName><shortdesc>
		 
		 Returns a sequence that aggregates values using functions passed as arguments, using 
		 deferred execution and returning the values accumulated values as they are returned.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A sequence of type TAccumulate that can be enumerated
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>seed</apiItemName><apiType value="Object"/><apiDesc>The initial value for the accumulation
		 </apiDesc></apiParam><apiParam><apiItemName>accumulator</apiItemName><apiType value="Function"/><apiDesc>A function that returns the new accumulated value: 
		        function(accumulate : TAccumulate, element : TElement) : TAccumulate
		 </apiDesc></apiParam><apiParam><apiItemName>resultSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A function that maps the final accumulate value before being returned
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns a sequence that aggregates values using functions passed as arguments, using 
		 deferred execution and returning the values accumulated values as they are returned.
		 
		 Accumulates a value, starting with seed, by calling accumulator for each value in the 
		 source sequence and using the return value as the new accumulated value. Each time  
		 a new value is accumulated, the accumulated value is (optonally) mapped through 
		 resultSelector before being returned.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:sequenceEqual"><apiName>sequenceEqual</apiName><shortdesc>
		 
		 Determines whether two sequences are equal.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>true if the sequences are of equal length and all of their values are equal
		 </apiDesc><apiType value="Boolean"/></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier><apiDesc>Ths sequence to compare to the source
		 </apiDesc></apiParam><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>A function that will determine equality between left and right values:
		     function(left : TLeft, right : TRight) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Determines whether two sequences are equal. Uses immediate execution 
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:singleOrDefault"><apiName>singleOrDefault</apiName><shortdesc>
		 
		 Returns the first element in the sequence or throws an IllegalOperationError 
		 if the sequence does contains multiple values, but returns a default value if 
		 the sequence returns no values.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The first matching value in the sequence or defaultValue
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>defaultValue</apiItemName><apiType value="Object"/><apiData>null</apiData><apiDesc>A defaultValue to 
		 </apiDesc></apiParam><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A predicate used to match values: function(element : TElement) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns the first element in the sequence or throws an IllegalOperationError 
		 if the sequence does contains multiple values, but returns a default value if 
		 the sequence returns no values. If predicate is supplied, the first value to match 
		 the predicate will be returned with an IllegalOperationError 
		 being thrown if the sequence contains more than one match and a default value being 
		 returned if no matches are found
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:single"><apiName>single</apiName><shortdesc>
		 
		 Returns the first element in the sequence or throws an IllegalOperationError 
		 if the sequence does not contain exactly one value.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The first value in the sequence or the first value in the sequence that matches predicate
		 </apiDesc><apiType value="Object"/></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A predicate used to match values: function(element : TElement) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns the first element in the sequence or throws an IllegalOperationError 
		 if the sequence does not contain exactly one value. If predicate is supplied, 
		 the first value to match the predicate will be returned with an IllegalOperationError 
		 being thrown if the sequence does not contain exactly one match
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:skipLast"><apiName>skipLast</apiName><shortdesc>
		 
		 Returns a new sequence that excludes the specified number of values from 
		 the end of the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing values of the same type as the source sequence
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of elements to skip from the end of source sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns a new sequence that excludes the specified number of values from 
		 the end of the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:skipWhile"><apiName>skipWhile</apiName><shortdesc>
		 
		 Returns a new sequence that skips values from the source sequence 
		 until a specified predicate returns false, at which point values will be 
		 returned from the rest of sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing values of the same type as the source sequence
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>A function that determines whether values should still be skipped 
		     from the source sequence: function(element:TElement) : Boolean 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns a new sequence that skips values from the source sequence 
		 until a specified predicate returns false, at which point values will be 
		 returned from the rest of sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:skip"><apiName>skip</apiName><shortdesc>
		 
		 Returns a new sequence that excludes the specified number of values from 
		 the start of the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing values of the same type as the source sequence
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of elements to skip from the source sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns a new sequence that excludes the specified number of values from 
		 the start of the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:sum"><apiName>sum</apiName><shortdesc>
		 
		 Returns the total numeric value of every value in the sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The summed values of each element in the sequence
		 </apiDesc><apiType value="Number"/></apiReturn><apiParam><apiItemName>valueSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, can be used to specify the numeric 
		        value for each element in the sequence 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns the total numeric value of every value in the sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:takeLast"><apiName>takeLast</apiName><shortdesc>
		 
		 Returns a new sequence that includes a maximum number of elements to take from 
		 the end of the first sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing values of the same type as the source sequence
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of elements to take from the end of source sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns a new sequence that includes a maximum number of elements to take from 
		 the end of the first sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:takeWhile"><apiName>takeWhile</apiName><shortdesc>
		 
		 Returns a new sequence that includes values from the source sequence 
		 until a specified predicate returns false, at which point the sequence will end 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing values of the same type as the source sequence
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>A function that determines whether values should still be taken 
		     from the source sequence: function(element:TElement) : Boolean 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns a new sequence that includes values from the source sequence 
		 until a specified predicate returns false, at which point the sequence will end 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:take"><apiName>take</apiName><shortdesc>
		 
		 Returns a new sequence that includes a maximum number of elements from the first sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing values of the same type as the source sequence
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of elements to take from the source sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns a new sequence that includes a maximum number of elements from the first sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:toArray"><apiName>toArray</apiName><shortdesc>
		 
		 Retrieves an array containing all the values in the sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An Array containing values of the same type as the source sequence
		 </apiDesc><apiType value="Array"/></apiReturn></apiOperationDef><apiDesc>
		 
		 Retrieves an array containing all the values in the sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:toDictionary"><apiName>toDictionary</apiName><shortdesc>
		 
		 Converts the sequence to a Dictionary.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Dictionary
		 </apiDesc><apiType value="flash.utils:Dictionary"/></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>Retrieves the key for each element in the sequence
		 </apiDesc></apiParam><apiParam><apiItemName>elementSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, provides the "values"  
		     in the lookup. If not specified, the original element will be used
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Converts the sequence to a Dictionary. Uses immediate execution
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:toLookup"><apiName>toLookup</apiName><shortdesc>
		 
		 Converts the sequence to an ILookup, which is simiular to a Dictionary with the following 
		 differences:
		 
		 
		 Supports null keys
		 Returns an empty sequence for requests for keys that do not exist
		 
		 
		 Uses immediate execution
		 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An ILookup
		 </apiDesc><apiOperationClassifier>raix.interactive:ILookup</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>Retrieves the key for each element in the sequence
		 </apiDesc></apiParam><apiParam><apiItemName>elementSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, provides the "values"  
		     in the lookup. If not specified, the original element will be used
		 </apiDesc></apiParam><apiParam><apiItemName>keyHashSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If the value returned by keySelector is not natively 
		        comparable (ie. String, u/int, Number, Boolean), keyHashSelector can be used to 
		        provide comparable values for the keys: function(key : TKey) : THash
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Converts the sequence to an ILookup, which is simiular to a Dictionary with the following 
		 differences:
		 
		 <ul>
		 <li>Supports null keys</li>
		 <li>Returns an empty sequence for requests for keys that do not exist</li>
		 </ul>
		 
		 Uses immediate execution
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:toObservable"><apiName>toObservable</apiName><shortdesc>
		 
		 Converts the interactive sequence to an observable sequence, optionally using a scheduler 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence that contains values of the same type as the source sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>(optional) The scheduler to use to distribute the values. Defaults to 
		     Scheduler.asynchronous
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Converts the interactive sequence to an observable sequence, optionally using a scheduler 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:union"><apiName>union</apiName><shortdesc>
		 
		 Returns a new sequence that contains the unique values across two sequences
		 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A new sequence containing the distinct values across both sequences 
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiType value="any"/><apiDesc>The right side of the union. Can be any value that can be converted 
		              to an IEnumerable using toEnumerable
		 </apiDesc></apiParam><apiParam><apiItemName>hashSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) If specified, returns a unique value for the element:
		                     function(element : TElement) : THash
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns a new sequence that contains the unique values across two sequences
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.interactive:AbsEnumerable:zip"><apiName>zip</apiName><shortdesc>
		 
		 Pairs values from two sequences in order and uses a selector function to project the results
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A sequence containing values of type TResult
		 </apiDesc><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier><apiDesc>The sequence to pair with the left (source) sequence
		 </apiDesc></apiParam><apiParam><apiItemName>resultSelector</apiItemName><apiType value="Function"/><apiDesc>A function to map values from the left and right sequences:
		     function(left : TLeft, right : TRight) : TResult
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Pairs values from two sequences in order and uses a selector function to project the results
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiOperation id="globalOperation:raix.interactive:toEnumerable"><apiName>toEnumerable</apiName><shortdesc>
	 Converts a value to an IEnumerable sequence.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.interactive:IEnumerable</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/></apiParam></apiOperationDef><apiDesc>
	 Converts a value to an IEnumerable sequence. It can be considered to have the following overloads:
	 
	 <ul>
	 <li>function():IEnumerable - returns an empty sequence</li>
	 <li>function(array : Array):IEnumerable - returns a sequence that wraps an array</li>
	 <li>function(enumerable : IEnumerable):IEnumerable - returns enumerable</li>
	 <li>function(proxy : Proxy):IEnumerable - returns enumerable that wraps an enumerable Proxy</li>
	 <li>function(value : :IEnumerable - returns enumerable that contains a single value</li>
	 </ul>
	 </apiDesc></apiOperationDetail></apiOperation></apiPackage><apiPackage id="raix.reactive.flex"><apiName>raix.reactive.flex</apiName><apiDetail/><apiClassifier id="raix.reactive.flex:IObservableResponder"><apiName>IObservableResponder</apiName><shortdesc>
	 An observable sequence that is also an mx.rpc.IResponse
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseInterface>mx.rpc:IResponder</apiBaseInterface><apiBaseInterface>raix.reactive:IObservable</apiBaseInterface><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 An observable sequence that is also an mx.rpc.IResponse
	 </apiDesc></apiClassifierDetail></apiClassifier><apiClassifier id="raix.reactive.flex:ObservableResponder"><apiName>ObservableResponder</apiName><shortdesc>
	 Concrete implementation of an observable sequence that is also an mx.rpc.IResponder
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive.flex:IObservableResponder</apiBaseInterface><apiBaseClassifier>raix.reactive:AbsObservable</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Concrete implementation of an observable sequence that is also an mx.rpc.IResponder
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive.flex:ObservableResponder:ObservableResponder"><apiName>ObservableResponder</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>valueClass</apiItemName><apiType value="Class"/></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive.flex:ObservableResponder:fault"><apiName>fault</apiName><shortdesc>
		 Implementation of mx.rpc.IResponder.fault()
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>info</apiItemName><apiType value="Object"/></apiParam></apiOperationDef><apiDesc>
		 Implementation of mx.rpc.IResponder.fault()
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.flex:ObservableResponder:result"><apiName>result</apiName><shortdesc>
		 Implementation of mx.rpc.IResponder.result()
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>data</apiItemName><apiType value="Object"/></apiParam></apiOperationDef><apiDesc>
		 Implementation of mx.rpc.IResponder.result()
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.flex:ObservableResponder:subscribeWith"><apiName>subscribeWith</apiName><shortdesc>
		 
		 Subscribes to this observable using the supplied observer
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>An instance of ICancelable that can be used to unsubscribe at anytime by calling <codeph>cancel()</codeph> 
		 </apiDesc><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>observer</apiItemName><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
		 
		 Subscribes to this observable using the supplied observer
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="raix.reactive.flex:FlexObservable"><apiName>FlexObservable</apiName><shortdesc/><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef></apiClassifierDetail><apiConstructor id="raix.reactive.flex:FlexObservable:FlexObservable"><apiName>FlexObservable</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive.flex:FlexObservable:fromAsyncPattern"><apiName>fromAsyncPattern</apiName><shortdesc>
		 Creates an observable sequence from a function that returns an AsyncToken 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>valueClass</apiItemName><apiType value="Class"/><apiDesc>The class of the value returned by the AsyncToken
		 </apiDesc></apiParam><apiParam><apiItemName>asyncMethod</apiItemName><apiType value="Function"/><apiDesc>The method to execute when a new subscription occurs. This method must return AsyncToken
		 </apiDesc></apiParam><apiParam><apiItemName>args</apiItemName><apiType value="Array"/><apiDesc>The arguments to supply to asyncMethod
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates an observable sequence from a function that returns an AsyncToken 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.flex:FlexObservable:fromCollection"><apiName>fromCollection</apiName><shortdesc>
		 Creates a sequence consisting of the values in a collection 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of elementType
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>elementClass</apiItemName><apiType value="Class"/><apiDesc>The class common to all values in values
		 </apiDesc></apiParam><apiParam><apiItemName>collection</apiItemName><apiType value="mx.collections:ICollectionView"/><apiDesc>The collection of values to iterate through
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler used to control flow
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence consisting of the values in a collection 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.flex:FlexObservable:fromList"><apiName>fromList</apiName><shortdesc>
		 Creates a sequence consisting of the values in a list 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of elementType
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>elementClass</apiItemName><apiType value="Class"/><apiDesc>The class common to all values in values
		 </apiDesc></apiParam><apiParam><apiItemName>list</apiItemName><apiType value="mx.collections:IList"/><apiDesc>The list of values to iterate through
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler used to control flow
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence consisting of the values in a list 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.flex:FlexObservable:fromViewCursor"><apiName>fromViewCursor</apiName><shortdesc>
		 Creates a sequence consisting of the values in a view cursor 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of elementClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>cursor</apiItemName><apiType value="mx.collections:IViewCursor"/><apiDesc>The class common to all values in values
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The view cursor of values to iterate through
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence consisting of the values in a view cursor 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.flex:FlexObservable:responder"><apiName>responder</apiName><shortdesc>
		 Creates an observable sequence that is also an IResponder 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive.flex:IObservableResponder</apiOperationClassifier></apiReturn><apiParam><apiItemName>valueClass</apiItemName><apiType value="Class"/><apiDesc>The valueClass of the returned sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates an observable sequence that is also an IResponder 
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier></apiPackage><apiPackage id="raix.reactive.scheduling"><apiName>raix.reactive.scheduling</apiName><apiDetail/><apiClassifier id="raix.reactive.scheduling:GreenThreadScheduler"><apiName>GreenThreadScheduler</apiName><shortdesc>
	 A scheduler that distributes work on a timer, limiting the total execution 
	 time per 'switch' to maintain a framerate
	 
	 Adding more work results in the work taking longer to complete, but the 
	 framerate remaining constant
	 
	 To benefit from GreenThreadScheduler, scheduled actions should execute in 
	 this smallest possible time (ie.</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive.scheduling:IScheduler</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A scheduler that distributes work on a timer, limiting the total execution 
	 time per 'switch' to maintain a framerate
	 
	 <p>Adding more work results in the work taking longer to complete, but the 
	 framerate remaining constant</p>
	 
	 <p>To benefit from GreenThreadScheduler, scheduled actions should execute in 
	 this smallest possible time (ie. be designed to be run many times</p>
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive.scheduling:GreenThreadScheduler:GreenThreadScheduler"><apiName>GreenThreadScheduler</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>contextSwitchObservable</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive.scheduling:GreenThreadScheduler:schedule"><apiName>schedule</apiName><shortdesc>
		 
		 Schedules a function to be run, either immediately or in the future 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An ICancelable that will stop the action from being run, if it hasn't already
		 </apiDesc><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>action</apiItemName><apiType value="Function"/><apiDesc>The function to run
		 </apiDesc></apiParam><apiParam><apiItemName>dueTime</apiItemName><apiType value="int"/><apiData>0</apiData><apiDesc>The time, in milliseconds, after which action should be executed. If 0, action should be executed at the first available opportunity
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Schedules a function to be run, either immediately or in the future 
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive.scheduling:GreenThreadScheduler:contextSwitchTime:get"><apiName>contextSwitchTime</apiName><shortdesc>
		 Gets or sets the amount of time, in milliseconds, to allocate to 
		 execution on every context 'switch' 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="readwrite"/><apiType value="Number"/></apiValueDef><apiDesc>
		 Gets or sets the amount of time, in milliseconds, to allocate to 
		 execution on every context 'switch' 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive.scheduling:GreenThreadScheduler:instance:get"><apiName>instance</apiName><shortdesc>
		 Gets the singleton instance of this scheduler
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>raix.reactive.scheduling:GreenThreadScheduler</apiValueClassifier></apiValueDef><apiDesc>
		 Gets the singleton instance of this scheduler
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive.scheduling:GreenThreadScheduler:now:get"><apiName>now</apiName><shortdesc>
		 
		 Gets the current Date and time
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Date"/></apiValueDef><apiDesc>
		 
		 Gets the current Date and time
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive.scheduling:Scheduler"><apiName>Scheduler</apiName><shortdesc>
	 Provides static helpers to schedulers
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Provides static helpers to schedulers
	 </apiDesc></apiClassifierDetail><apiOperation id="raix.reactive.scheduling:Scheduler:scheduleRecursive"><apiName>scheduleRecursive</apiName><shortdesc>
		 Schedules a recursive action on an IScheduler 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An ICancelable that can be used to cancel the recursive schedule at any time
		 </apiDesc><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiDesc>The scheduler that will schedule each recursive call
		 </apiDesc></apiParam><apiParam><apiItemName>action</apiItemName><apiType value="Function"/><apiDesc>The action to call. The action will be called with one argument: a Function that call be called to reschedule the original action
		 </apiDesc></apiParam><apiParam><apiItemName>dueTime</apiItemName><apiType value="int"/><apiData>0</apiData><apiDesc>The amount of time to delay the call to ation
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Schedules a recursive action on an IScheduler 
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive.scheduling:Scheduler:asynchronous:get"><apiName>asynchronous</apiName><shortdesc>
		 Gets the default asynchronous scheduler
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>raix.reactive.scheduling:IScheduler</apiValueClassifier></apiValueDef><apiDesc>
		 Gets the default asynchronous scheduler
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive.scheduling:Scheduler:defaultScheduler:get"><apiName>defaultScheduler</apiName><shortdesc>
		 Gets the default scheduler
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>raix.reactive.scheduling:IScheduler</apiValueClassifier></apiValueDef><apiDesc>
		 Gets the default scheduler
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive.scheduling:Scheduler:greenThread:get"><apiName>greenThread</apiName><shortdesc>
		 Gets the GreenThreadScheduler singleton instance
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>raix.reactive.scheduling:GreenThreadScheduler</apiValueClassifier></apiValueDef><apiDesc>
		 Gets the GreenThreadScheduler singleton instance
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive.scheduling:Scheduler:immediate:get"><apiName>immediate</apiName><shortdesc>
		 Gets the ImmediateScheduler singleton instance
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>raix.reactive.scheduling:ImmediateScheduler</apiValueClassifier></apiValueDef><apiDesc>
		 Gets the ImmediateScheduler singleton instance
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive.scheduling:Scheduler:synchronous:get"><apiName>synchronous</apiName><shortdesc>
		 Gets the default synchronous scheduler
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>raix.reactive.scheduling:IScheduler</apiValueClassifier></apiValueDef><apiDesc>
		 Gets the default synchronous scheduler
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive.scheduling:IScheduler"><apiName>IScheduler</apiName><shortdesc>
	 Used to distribute workload
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 Used to distribute workload
	 </apiDesc></apiClassifierDetail><apiOperation id="raix.reactive.scheduling:IScheduler:raix.reactive.scheduling:IScheduler:schedule"><apiName>schedule</apiName><shortdesc>
		 Schedules a function to be run, either immediately or in the future 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An ICancelable that will stop the action from being run, if it hasn't already
		 </apiDesc><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>action</apiItemName><apiType value="Function"/><apiDesc>The function to run
		 </apiDesc></apiParam><apiParam><apiItemName>dueTime</apiItemName><apiType value="int"/><apiData>0</apiData><apiDesc>The time, in milliseconds, after which action should be executed. If 0, action should be executed at the first available opportunity
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Schedules a function to be run, either immediately or in the future 
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive.scheduling:IScheduler:raix.reactive.scheduling:IScheduler:now:get"><apiName>now</apiName><shortdesc>
		 Gets the current Date and time
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Date"/></apiValueDef><apiDesc>
		 Gets the current Date and time
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive.scheduling:ImmediateScheduler"><apiName>ImmediateScheduler</apiName><shortdesc>
	 A scheduler that executes actions immediately, or immediately
	 after their dueTime (if specified).</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive.scheduling:IScheduler</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A scheduler that executes actions immediately, or immediately
	 after their dueTime (if specified).
	 </apiDesc></apiClassifierDetail><apiOperation id="raix.reactive.scheduling:ImmediateScheduler:schedule"><apiName>schedule</apiName><shortdesc>
		 
		 Schedules a function to be run, either immediately or in the future 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An ICancelable that will stop the action from being run, if it hasn't already
		 </apiDesc><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>action</apiItemName><apiType value="Function"/><apiDesc>The function to run
		 </apiDesc></apiParam><apiParam><apiItemName>dueTime</apiItemName><apiType value="int"/><apiData>0</apiData><apiDesc>The time, in milliseconds, after which action should be executed. If 0, action should be executed at the first available opportunity
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Schedules a function to be run, either immediately or in the future 
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive.scheduling:ImmediateScheduler:instance:get"><apiName>instance</apiName><shortdesc>
		 Gets the singleton instance of this scheduler
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>raix.reactive.scheduling:ImmediateScheduler</apiValueClassifier></apiValueDef><apiDesc>
		 Gets the singleton instance of this scheduler
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive.scheduling:ImmediateScheduler:now:get"><apiName>now</apiName><shortdesc>
		 
		 Gets the current Date and time
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Date"/></apiValueDef><apiDesc>
		 
		 Gets the current Date and time
		 </apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage><apiPackage id="raix.reactive.subjects"><apiName>raix.reactive.subjects</apiName><apiDetail/><apiClassifier id="raix.reactive.subjects:ConnectableObservable"><apiName>ConnectableObservable</apiName><shortdesc>
	 Concrete implementation of IConnectableObservable
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive.subjects:IConnectableObservable</apiBaseInterface><apiBaseClassifier>raix.reactive:AbsObservable</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Concrete implementation of IConnectableObservable
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive.subjects:ConnectableObservable:ConnectableObservable"><apiName>ConnectableObservable</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiParam><apiParam><apiItemName>subject</apiItemName><apiOperationClassifier>raix.reactive:ISubject</apiOperationClassifier><apiData>null</apiData></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive.subjects:ConnectableObservable:connect"><apiName>connect</apiName><shortdesc>
		 
		 Makes this observable 'hot', so that values will be 
		 emitted whether there is a subscriber connected or not.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Makes this observable 'hot', so that values will be 
		 emitted whether there is a subscriber connected or not.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.subjects:ConnectableObservable:refCount"><apiName>refCount</apiName><shortdesc>
		 
		 Makes this observable 'hot' when an observer subscribes, and 
		 will cancel the source subscription when the last observer unsubscribes
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Makes this observable 'hot' when an observer subscribes, and 
		 will cancel the source subscription when the last observer unsubscribes
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.subjects:ConnectableObservable:subscribeWith"><apiName>subscribeWith</apiName><shortdesc>
		 
		 Subscribes to this observable using the supplied observer
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>An instance of ICancelable that can be used to unsubscribe at anytime by calling <codeph>cancel()</codeph> 
		 </apiDesc><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>observer</apiItemName><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
		 
		 Subscribes to this observable using the supplied observer
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="raix.reactive.subjects:AsyncSubject"><apiName>AsyncSubject</apiName><shortdesc>
	 A subject that replays the last value (or error) received to observers that subscribe 
	 after the sequence has completed
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive:ISubject</apiBaseInterface><apiBaseClassifier>raix.reactive:AbsObservable</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A subject that replays the last value (or error) received to observers that subscribe 
	 after the sequence has completed
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive.subjects:AsyncSubject:AsyncSubject"><apiName>AsyncSubject</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive.subjects:AsyncSubject:lastValue"><apiName>lastValue</apiName><shortdesc>
		 Gets the last value received, or throws an IllegalOperationError if no value 
		 has been received.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="Object"/></apiReturn></apiOperationDef><apiDesc>
		 Gets the last value received, or throws an IllegalOperationError if no value 
		 has been received.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.subjects:AsyncSubject:onCompleted"><apiName>onCompleted</apiName><shortdesc>
		 
		 Notifies the subscriber that the sequence has completed and 
		 that no more messages will be received
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 
		 Notifies the subscriber that the sequence has completed and 
		 that no more messages will be received
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.subjects:AsyncSubject:onError"><apiName>onError</apiName><shortdesc>
		 
		 Notifies the subscriber that the sequence has halted with an error 
		 and that no more messages will be received
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>err</apiItemName><apiType value="Error"/></apiParam></apiOperationDef><apiDesc>
		 
		 Notifies the subscriber that the sequence has halted with an error 
		 and that no more messages will be received
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.subjects:AsyncSubject:onNext"><apiName>onNext</apiName><shortdesc>
		 
		 Notifies the subscriber that a value has been received
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="Object"/></apiParam></apiOperationDef><apiDesc>
		 
		 Notifies the subscriber that a value has been received
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.subjects:AsyncSubject:subscribeWith"><apiName>subscribeWith</apiName><shortdesc>
		 
		 Subscribes to this observable using the supplied observer
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>An instance of ICancelable that can be used to unsubscribe at anytime by calling <codeph>cancel()</codeph> 
		 </apiDesc><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>observer</apiItemName><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
		 
		 Subscribes to this observable using the supplied observer
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="raix.reactive.subjects:ReplaySubject"><apiName>ReplaySubject</apiName><shortdesc/><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive:ISubject</apiBaseInterface><apiBaseClassifier>raix.reactive:AbsObservable</apiBaseClassifier></apiClassifierDef></apiClassifierDetail><apiConstructor id="raix.reactive.subjects:ReplaySubject:ReplaySubject"><apiName>ReplaySubject</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>bufferSize</apiItemName><apiType value="uint"/><apiData>0</apiData></apiParam><apiParam><apiItemName>window</apiItemName><apiType value="uint"/><apiData>0</apiData></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive.subjects:ReplaySubject:onCompleted"><apiName>onCompleted</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.subjects:ReplaySubject:onError"><apiName>onError</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>err</apiItemName><apiType value="Error"/></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.subjects:ReplaySubject:onNext"><apiName>onNext</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="Object"/></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.subjects:ReplaySubject:subscribeWith"><apiName>subscribeWith</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>observer</apiItemName><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier></apiParam></apiOperationDef></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="raix.reactive.subjects:IConnectableObservable"><apiName>IConnectableObservable</apiName><shortdesc>
	 Represents a 'pending' hot observable.</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive:IObservable</apiBaseInterface><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 Represents a 'pending' hot observable. Calling connect will turn the observable 
	 into a hot observable. Calling refCount will turn the observable into a hot observable 
	 when the first observer subscribes
	 </apiDesc></apiClassifierDetail><apiOperation id="raix.reactive.subjects:IConnectableObservable:raix.reactive.subjects:IConnectableObservable:connect"><apiName>connect</apiName><shortdesc>
		 Makes this observable 'hot', so that values will be 
		 emitted whether there is a subscriber connected or not.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Makes this observable 'hot', so that values will be 
		 emitted whether there is a subscriber connected or not.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.subjects:IConnectableObservable:raix.reactive.subjects:IConnectableObservable:refCount"><apiName>refCount</apiName><shortdesc>
		 Makes this observable 'hot' when an observer subscribes, and 
		 will cancel the source subscription when the last observer unsubscribes
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Makes this observable 'hot' when an observer subscribes, and 
		 will cancel the source subscription when the last observer unsubscribes
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier></apiPackage><apiPackage id="raix.reactive.testing"><apiName>raix.reactive.testing</apiName><apiDetail/><apiClassifier id="raix.reactive.testing:Subscription"><apiName>Subscription</apiName><shortdesc/><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef></apiClassifierDetail><apiConstructor id="raix.reactive.testing:Subscription:Subscription"><apiName>Subscription</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>subscribe</apiItemName><apiType value="Number"/></apiParam><apiParam><apiItemName>unsubscribe</apiItemName><apiType value="Number"/><apiData>unknown</apiData></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiValue id="raix.reactive.testing:Subscription:subscribe"><apiName>subscribe</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Number"/></apiValueDef></apiValueDetail></apiValue><apiValue id="raix.reactive.testing:Subscription:unsubscribe"><apiName>unsubscribe</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiType value="Number"/></apiValueDef></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive.testing:MockObserver"><apiName>MockObserver</apiName><shortdesc/><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive:IObserver</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef></apiClassifierDetail><apiConstructor id="raix.reactive.testing:MockObserver:MockObserver"><apiName>MockObserver</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.testing:TestScheduler</apiOperationClassifier></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive.testing:MockObserver:assertNotifications"><apiName>assertNotifications</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>expectedNotifications</apiItemName><apiType value="Array"/></apiParam><apiParam><apiItemName>failFunction</apiItemName><apiType value="Function"/></apiParam><apiParam><apiItemName>valueComparer</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam><apiParam><apiItemName>message</apiItemName><apiType value="String"/><apiData>null</apiData></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.testing:MockObserver:assertTimings"><apiName>assertTimings</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>recordedNotifications</apiItemName><apiType value="Array"/></apiParam><apiParam><apiItemName>failFunction</apiItemName><apiType value="Function"/></apiParam><apiParam><apiItemName>valueComparer</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam><apiParam><apiItemName>message</apiItemName><apiType value="String"/><apiData>null</apiData></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.testing:MockObserver:assertValues"><apiName>assertValues</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>expectedValues</apiItemName><apiType value="Array"/></apiParam><apiParam><apiItemName>failFunction</apiItemName><apiType value="Function"/></apiParam><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam><apiParam><apiItemName>message</apiItemName><apiType value="String"/><apiData>null</apiData></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.testing:MockObserver:completed"><apiName>completed</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="Boolean"/></apiReturn></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.testing:MockObserver:error"><apiName>error</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="Error"/></apiReturn></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.testing:MockObserver:hasError"><apiName>hasError</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="Boolean"/></apiReturn></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.testing:MockObserver:onCompleted"><apiName>onCompleted</apiName><shortdesc>
		 
		 Notifies the subscriber that the sequence has completed and 
		 that no more messages will be received
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 
		 Notifies the subscriber that the sequence has completed and 
		 that no more messages will be received
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.testing:MockObserver:onError"><apiName>onError</apiName><shortdesc>
		 
		 Notifies the subscriber that the sequence has halted with an error 
		 and that no more messages will be received
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>error</apiItemName><apiType value="Error"/></apiParam></apiOperationDef><apiDesc>
		 
		 Notifies the subscriber that the sequence has halted with an error 
		 and that no more messages will be received
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.testing:MockObserver:onNext"><apiName>onNext</apiName><shortdesc>
		 
		 Notifies the subscriber that a value has been received
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="Object"/></apiParam></apiOperationDef><apiDesc>
		 
		 Notifies the subscriber that a value has been received
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive.testing:MockObserver:recordedNotifications:get"><apiName>recordedNotifications</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Array"/></apiValueDef></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive.testing:HotObservable"><apiName>HotObservable</apiName><shortdesc/><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>raix.reactive:AbsObservable</apiBaseClassifier></apiClassifierDef></apiClassifierDetail><apiConstructor id="raix.reactive.testing:HotObservable:HotObservable"><apiName>HotObservable</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.testing:TestScheduler</apiOperationClassifier></apiParam><apiParam><apiItemName>messages</apiItemName><apiType value="Array"/></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive.testing:HotObservable:subscribeWith"><apiName>subscribeWith</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>observer</apiItemName><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiValue id="raix.reactive.testing:HotObservable:observers:get"><apiName>observers</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Array"/></apiValueDef></apiValueDetail></apiValue><apiValue id="raix.reactive.testing:HotObservable:subscriptions:get"><apiName>subscriptions</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Array"/></apiValueDef></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive.testing:TestScheduler"><apiName>TestScheduler</apiName><shortdesc>
	 
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive.scheduling:IScheduler</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive.testing:TestScheduler:TestScheduler"><apiName>TestScheduler</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive.testing:TestScheduler:createColdObservable"><apiName>createColdObservable</apiName><shortdesc>
		 Creates a sequence from "recorded" values that will start a new timeline for each susbcriber  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence that will start a new timeline for each susbcriber
		 </apiDesc><apiOperationClassifier>raix.reactive.testing:ColdObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>recordedNotifications</apiItemName><apiType value="Array"/><apiDesc>An array of Recorded instances
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence from "recorded" values that will start a new timeline for each susbcriber  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.testing:TestScheduler:createHotObservable"><apiName>createHotObservable</apiName><shortdesc>
		 Creates a sequence from "recorded" values that will share a timeline between all subscribers  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence that will share a timeline between all subscribers
		 </apiDesc><apiOperationClassifier>raix.reactive.testing:HotObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>recordedNotifications</apiItemName><apiType value="Array"/><apiDesc>An array of Recorded instances
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence from "recorded" values that will share a timeline between all subscribers  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.testing:TestScheduler:runTo"><apiName>runTo</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>time</apiItemName><apiType value="Number"/></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.testing:TestScheduler:run"><apiName>run</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.reactive.testing:TestScheduler:schedule"><apiName>schedule</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>action</apiItemName><apiType value="Function"/></apiParam><apiParam><apiItemName>dueTime</apiItemName><apiType value="int"/><apiData>0</apiData></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiValue id="raix.reactive.testing:TestScheduler:actionCount:get"><apiName>actionCount</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="uint"/></apiValueDef></apiValueDetail></apiValue><apiValue id="raix.reactive.testing:TestScheduler:now:get"><apiName>now</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Date"/></apiValueDef></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive.testing:Recorded"><apiName>Recorded</apiName><shortdesc/><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef></apiClassifierDetail><apiConstructor id="raix.reactive.testing:Recorded:Recorded"><apiName>Recorded</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>time</apiItemName><apiType value="Number"/></apiParam><apiParam><apiItemName>notification</apiItemName><apiOperationClassifier>raix.reactive:Notification</apiOperationClassifier></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiValue id="raix.reactive.testing:Recorded:time:get"><apiName>time</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Number"/></apiValueDef></apiValueDetail></apiValue><apiValue id="raix.reactive.testing:Recorded:value:get"><apiName>value</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiValueClassifier>raix.reactive:Notification</apiValueClassifier></apiValueDef></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive.testing:ColdObservable"><apiName>ColdObservable</apiName><shortdesc/><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>raix.reactive:AbsObservable</apiBaseClassifier></apiClassifierDef></apiClassifierDetail><apiConstructor id="raix.reactive.testing:ColdObservable:ColdObservable"><apiName>ColdObservable</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.testing:TestScheduler</apiOperationClassifier></apiParam><apiParam><apiItemName>messages</apiItemName><apiType value="Array"/></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive.testing:ColdObservable:subscribeWith"><apiName>subscribeWith</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>observer</apiItemName><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiValue id="raix.reactive.testing:ColdObservable:subscriptions:get"><apiName>subscriptions</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Array"/></apiValueDef></apiValueDetail></apiValue></apiClassifier></apiPackage><apiPackage id="raix.reactive"><apiName>raix.reactive</apiName><apiDetail/><apiClassifier id="raix.reactive:MutableCancelable"><apiName>MutableCancelable</apiName><shortdesc>
	A cancelable resource than is not immediately available
	</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive:ICancelable</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	A cancelable resource than is not immediately available
	</apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:MutableCancelable:MutableCancelable"><apiName>MutableCancelable</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:MutableCancelable:cancel"><apiName>cancel</apiName><shortdesc>
		 Cancels the operation for current and future innerCancelable values
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 Cancels the operation for current and future innerCancelable values
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:MutableCancelable:cancelable:set"><apiName>cancelable</apiName><shortdesc>
		 Assigns the cancelable operation.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="write"/><apiValueClassifier>raix.reactive:ICancelable</apiValueClassifier></apiValueDef><apiDesc>
		 Assigns the cancelable operation.
		 
		 If an existing value exists for innerCancelable, it will be canceled.
		 
		 If cancel() has already been called on this FutureCancelable, the value 
		 will be instantly canceled and innerCancelable will be null
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:Observer"><apiName>Observer</apiName><shortdesc>
	 Provides static methods that create observers
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Provides static methods that create observers
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:Observer:Observer"><apiName>Observer</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:Observer:create"><apiName>create</apiName><shortdesc>
		 Creates an IObserver from onNext, onCompleted and onError functions
		 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier></apiReturn><apiParam><apiItemName>onNext</apiItemName><apiType value="Function"/><apiDesc>The function to call when a value is received
		 </apiDesc></apiParam><apiParam><apiItemName>onCompleted</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function to call when the sequence has complted
		 </apiDesc></apiParam><apiParam><apiItemName>onError</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function to call if an error occurs in the sequence 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates an IObserver from onNext, onCompleted and onError functions
		 
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="raix.reactive:TimeStamped"><apiName>TimeStamped</apiName><shortdesc>
	 A wrapper that adds a timestamp to a value
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A wrapper that adds a timestamp to a value
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:TimeStamped:TimeStamped"><apiName>TimeStamped</apiName><shortdesc>
		 Creates a TimeStamped wrapper 
		 </shortdesc><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>value</apiItemName><apiType value="Object"/><apiDesc>The value from the original sequence
		 </apiDesc></apiParam><apiParam><apiItemName>time</apiItemName><apiType value="Number"/><apiDesc>The timestamp value
		 </apiDesc></apiParam></apiConstructorDef><apiDesc>
		 Creates a TimeStamped wrapper 
		 </apiDesc></apiConstructorDetail></apiConstructor><apiValue id="raix.reactive:TimeStamped:timestamp:get"><apiName>timestamp</apiName><shortdesc>
		 Gets the timestamp value 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Number"/></apiValueDef><apiDesc>
		 Gets the timestamp value 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:TimeStamped:value:get"><apiName>value</apiName><shortdesc>
		 Gets the original value 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Object"/></apiValueDef><apiDesc>
		 Gets the original value 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:TimeInterval"><apiName>TimeInterval</apiName><shortdesc>
	 A wrapper that adds the time interval, in milliseconds,
	 since the last values 
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A wrapper that adds the time interval, in milliseconds,
	 since the last values 
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:TimeInterval:TimeInterval"><apiName>TimeInterval</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>value</apiItemName><apiType value="Object"/></apiParam><apiParam><apiItemName>interval</apiItemName><apiType value="Number"/></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiValue id="raix.reactive:TimeInterval:interval:get"><apiName>interval</apiName><shortdesc>
		 Gets the internal, in milliseconds, 
		 since the last value
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Number"/></apiValueDef><apiDesc>
		 Gets the internal, in milliseconds, 
		 since the last value
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:TimeInterval:value:get"><apiName>value</apiName><shortdesc>
		 Gets the original value
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Object"/></apiValueDef><apiDesc>
		 Gets the original value
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:Unit"><apiName>Unit</apiName><shortdesc>
	 Represents a valueClass that can be used when 
	 an observable sequence logically has no valueClass
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Represents a valueClass that can be used when 
	 an observable sequence logically has no valueClass
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:Unit:Unit"><apiName>Unit</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="raix.reactive:BooleanCancelable"><apiName>BooleanCancelable</apiName><shortdesc>
	 Represents a cancelable operation, the canceled status of which can 
	 be checked by isCanceled 
	</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive:ICancelable</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Represents a cancelable operation, the canceled status of which can 
	 be checked by isCanceled 
	</apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:BooleanCancelable:BooleanCancelable"><apiName>BooleanCancelable</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:BooleanCancelable:cancel"><apiName>cancel</apiName><shortdesc>
		 Cancels the operation.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 Cancels the operation. isCanceled will return true after this call.
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:BooleanCancelable:isCanceled:get"><apiName>isCanceled</apiName><shortdesc>
		 Determines if canceled() has been called on this instance
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc>
		 Determines if canceled() has been called on this instance
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:IGroupedObservable"><apiName>IGroupedObservable</apiName><shortdesc/><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive:IObservable</apiBaseInterface><apiBaseClassifier/></apiClassifierDef></apiClassifierDetail><apiValue id="raix.reactive:IGroupedObservable:raix.reactive:IGroupedObservable:key:get"><apiName>key</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Object"/></apiValueDef></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:OnError"><apiName>OnError</apiName><shortdesc>
	 A Notification for an onError call
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>raix.reactive:Notification</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A Notification for an onError call
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:OnError:OnError"><apiName>OnError</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>error</apiItemName><apiType value="Error"/></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:OnError:accept"><apiName>accept</apiName><shortdesc>
		 Calls onError if it's not null
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>onNext</apiItemName><apiType value="Function"/></apiParam><apiParam><apiItemName>onCompleted</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam><apiParam><apiItemName>onError</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 Calls onError if it's not null
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:OnError:error:get"><apiName>error</apiName><shortdesc>
		 Gets the error for this message 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Error"/></apiValueDef><apiDesc>
		 Gets the error for this message 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:OnError:hasValue:get"><apiName>hasValue</apiName><shortdesc>
		 Always returns false since no values are associated with errors 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc>
		 Always returns false since no values are associated with errors 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:OnError:kind:get"><apiName>kind</apiName><shortdesc>
		 Always returns NotificationKind.ON_ERROR 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="int"/></apiValueDef><apiDesc>
		 Always returns NotificationKind.ON_ERROR 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:OnError:value:get"><apiName>value</apiName><shortdesc>
		 Always returns null since no values are associated with errors 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Object"/></apiValueDef><apiDesc>
		 Always returns null since no values are associated with errors 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:ISubject"><apiName>ISubject</apiName><shortdesc>
	 A resource that is both observable and an observer
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive:IObservable</apiBaseInterface><apiBaseInterface>raix.reactive:IObserver</apiBaseInterface><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 A resource that is both observable and an observer
	 </apiDesc></apiClassifierDetail></apiClassifier><apiClassifier id="raix.reactive:OnNext"><apiName>OnNext</apiName><shortdesc>
	 A Notification for an onNext call
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>raix.reactive:Notification</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A Notification for an onNext call
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:OnNext:OnNext"><apiName>OnNext</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>value</apiItemName><apiType value="Object"/></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:OnNext:accept"><apiName>accept</apiName><shortdesc>
		 Calls onNext if it's not null
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>onNext</apiItemName><apiType value="Function"/></apiParam><apiParam><apiItemName>onCompleted</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam><apiParam><apiItemName>onError</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 Calls onNext if it's not null
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:OnNext:error:get"><apiName>error</apiName><shortdesc>
		 Always returns false since no errors are associated with values 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Error"/></apiValueDef><apiDesc>
		 Always returns false since no errors are associated with values 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:OnNext:hasValue:get"><apiName>hasValue</apiName><shortdesc>
		 Always returns true 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc>
		 Always returns true 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:OnNext:kind:get"><apiName>kind</apiName><shortdesc>
		 Always returns NotificationKind.ON_NEXT 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="int"/></apiValueDef><apiDesc>
		 Always returns NotificationKind.ON_NEXT 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:OnNext:value:get"><apiName>value</apiName><shortdesc>
		 Gets the value from the message 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Object"/></apiValueDef><apiDesc>
		 Gets the value from the message 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:TimeoutError"><apiName>TimeoutError</apiName><shortdesc>
	 An error thrown by Observable.timeout by default
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Error</apiBaseClassifier></apiClassifierDef><apiDesc>
	 An error thrown by Observable.timeout by default
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:TimeoutError:TimeoutError"><apiName>TimeoutError</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>message</apiItemName><apiType value="String"/></apiParam><apiParam><apiItemName>id</apiItemName><apiType value="int"/><apiData>0</apiData></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor></apiClassifier><apiClassifier id="raix.reactive:OnCompleted"><apiName>OnCompleted</apiName><shortdesc>
	 A Notification for an onCompleted call
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>raix.reactive:Notification</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A Notification for an onCompleted call
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:OnCompleted:OnCompleted"><apiName>OnCompleted</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:OnCompleted:accept"><apiName>accept</apiName><shortdesc>
		 Calls onCompleted if it's not null
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>onNext</apiItemName><apiType value="Function"/></apiParam><apiParam><apiItemName>onCompleted</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam><apiParam><apiItemName>onError</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 Calls onCompleted if it's not null
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:OnCompleted:error:get"><apiName>error</apiName><shortdesc>
		 Always returns false since no errors are associated with completion 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Error"/></apiValueDef><apiDesc>
		 Always returns false since no errors are associated with completion 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:OnCompleted:hasValue:get"><apiName>hasValue</apiName><shortdesc>
		 Always returns false since no values are associated with completion 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc>
		 Always returns false since no values are associated with completion 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:OnCompleted:kind:get"><apiName>kind</apiName><shortdesc>
		 Always returns NotificationKind.ON_COMPLETED 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="int"/></apiValueDef><apiDesc>
		 Always returns NotificationKind.ON_COMPLETED 
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:OnCompleted:value:get"><apiName>value</apiName><shortdesc>
		 Always returns null since no values are associated with completion 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiIsOverride/><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Object"/></apiValueDef><apiDesc>
		 Always returns null since no values are associated with completion 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:AbsObservable"><apiName>AbsObservable</apiName><shortdesc>
	 Subclass this class only if you want to implement a completely custom IObservable.</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive:IObservable</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Subclass this class only if you want to implement a completely custom IObservable.
	 
	 <p>If you can avoid it, however, try to stick to subclassing Subject or using 
	 one of the creation methods.</p>
	 
	 <p>This class may be made inaccessible in future revisions</p>
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:AbsObservable:AbsObservable"><apiName>AbsObservable</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:AbsObservable:aggregate"><apiName>aggregate</apiName><shortdesc>
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>accumulator</apiItemName><apiType value="Function"/></apiParam><apiParam><apiItemName>initialValue</apiItemName><apiType value="Object"/><apiData>null</apiData></apiParam><apiParam><apiItemName>useInitialValue</apiItemName><apiType value="Boolean"/><apiData>false</apiData></apiParam></apiOperationDef><apiDesc>
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:all"><apiName>all</apiName><shortdesc>
		 
		 Determines if all values in the source sequence satisfy a condition
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Boolean
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The predicate that determines if a value in the sequence is valid. 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Determines if all values in the source sequence satisfy a condition
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:and"><apiName>and</apiName><shortdesc>
		  
		 Creates a pattern by combining the current source with right.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A pattern representing both sequences
		 </apiDesc><apiOperationClassifier>raix.reactive:Pattern</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The other sequence to combine with the pattern.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		  
		 Creates a pattern by combining the current source with right.
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:any"><apiName>any</apiName><shortdesc>
		 
		 Determines if the source sequence contains a value that satisfies a condition
		  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Boolean
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) The predicate that determines if a value in the sequence is valid. 
		 If null, the returned sequence will emit true if the source sequence contains any values or false if it is empty.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Determines if the source sequence contains a value that satisfies a condition
		  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:asObservable"><apiName>asObservable</apiName><shortdesc>
		 
		 Hides the source sequence so it cannot be cast back to its concrete implementation  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Hides the source sequence so it cannot be cast back to its concrete implementation  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:average"><apiName>average</apiName><shortdesc>
		 
		 Returns the average value of all the elements in the source sequence
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TSource values
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>valueSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) The selector function that returns a numeric value from the source value  
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Returns the average value of all the elements in the source sequence
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:bufferWithCount"><apiName>bufferWithCount</apiName><shortdesc>
		 
		 Emits the values from a source sequence in groups of a specific size  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of arrays of the the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to buffer
		 </apiDesc></apiParam><apiParam><apiItemName>skip</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of values to offset after the buffer is emitted.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Emits the values from a source sequence in groups of a specific size  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:bufferWithTimeOrCount"><apiName>bufferWithTimeOrCount</apiName><shortdesc>
		 
		 Buffers values into an array, with one array for either a maximum period of time or a maximum number 
		 of values, whichever occurs first
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of observable sequences with the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeMs</apiItemName><apiType value="uint"/><apiDesc>The maximum amount of time to buffer values for
		 </apiDesc></apiParam><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The maximum amount of values to include in a single buffer
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 
		 Buffers values into an array, with one array for either a maximum period of time or a maximum number 
		 of values, whichever occurs first
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:bufferWithTime"><apiName>bufferWithTime</apiName><shortdesc>
		 
		 Emits the values from a source sequence in groups of a specific size  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Arrays of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeMs</apiItemName><apiType value="uint"/><apiDesc>The amount of time to buffer before the values are released
		 </apiDesc></apiParam><apiParam><apiItemName>timeShiftMs</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The amount of time to offset after the buffer is emitted
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Emits the values from a source sequence in groups of a specific size  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:cast"><apiName>cast</apiName><shortdesc>
		 
		 Forces values from a source sequence to be of a specific class
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>valueClass</apiItemName><apiType value="Class"/><apiDesc>The valueClass of the output sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Forces values from a source sequence to be of a specific class
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:catchErrorDefer"><apiName>catchErrorDefer</apiName><shortdesc>
		 
		 Runs a specific sequence, determined at runtime, when an error occurs
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>errorClass</apiItemName><apiType value="Class"/><apiDesc>The class (and superclass) of error to act on
		 </apiDesc></apiParam><apiParam><apiItemName>deferFunc</apiItemName><apiType value="Function"/><apiDesc>The function to execute in the event of an error. 
		 Signature is <codeph>function(e : Error) : IObservable</codeph>
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Runs a specific sequence, determined at runtime, when an error occurs
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:catchError"><apiName>catchError</apiName><shortdesc>
		 
		 Runs a specific sequence when an error occurs
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to subscribe to when an error occurs
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Runs a specific sequence when an error occurs
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:chain"><apiName>chain</apiName><shortdesc>
		 
		 Chains together sequences, starting with the current sequence, using selector functions that 
		 return a sequence for values of the previous.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the values returned by the sequence returned by the last 
		 selector in the chain
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>functions</apiItemName><apiType value="Array"/><apiDesc>An array of functions that accept a value from the previous sequence and 
		        return a new sequence:
		        function (value : T) : IObservable
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Chains together sequences, starting with the current sequence, using selector functions that 
		 return a sequence for values of the previous.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:combineLatest"><apiName>combineLatest</apiName><shortdesc>
		 
		 Merges two sequences through a mapping function, using the latest value from either source 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of returnType 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to combine with
		 </apiDesc></apiParam><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function that combines values from the two sources. Signature is <codeph>function(left : this.valueClass, right : right.valueClass) : returnType</codeph>
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Merges two sequences through a mapping function, using the latest value from either source 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:concatMany"><apiName>concatMany</apiName><shortdesc>
		 
		 Evaluates a new sequence for each value using a selector function and waits for the returned 
		 sequence to complete before resolving the next sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An IObservable sequence containing the values returned
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>Accept a value of the source and returns the IObservable sequence to concatonate:
		     function(value:T) : IObservable
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Evaluates a new sequence for each value using a selector function and waits for the returned 
		 sequence to complete before resolving the next sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:concat"><apiName>concat</apiName><shortdesc>
		 
		 Concatonates multiple sequences by running each sequence as the previous one finishes
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequences to concatonate after the current sequence 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Concatonates multiple sequences by running each sequence as the previous one finishes
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:contains"><apiName>contains</apiName><shortdesc>
		 
		 Determines if the source sequence contains a specific value 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Boolean
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="Object"/><apiDesc>The value to check against the sequence
		 </apiDesc></apiParam><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function used to compare values. Default equality will be used if comparer is null.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Determines if the source sequence contains a specific value 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:count"><apiName>count</apiName><shortdesc>
		 
		 Returns the number of elements in the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of int
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Returns the number of elements in the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:delayUntil"><apiName>delayUntil</apiName><shortdesc>
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>dt</apiItemName><apiType value="Date"/></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 </apiDesc></apiOperationDetail><apiInheritDoc/></apiOperation><apiOperation id="raix.reactive:AbsObservable:delay"><apiName>delay</apiName><shortdesc>
		 
		 Delays all values in a sequences by a specified time 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>delayMs</apiItemName><apiType value="uint"/><apiDesc>The amount of time, in milliseconds, to delay
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler used to delay the values
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Delays all values in a sequences by a specified time 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:dematerialize"><apiName>dematerialize</apiName><shortdesc>
		 
		 Converts materialized values back into messages  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Converts materialized values back into messages  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:distinctUntilChanged"><apiName>distinctUntilChanged</apiName><shortdesc>
		 
		 Filters out consecutive duplicates from a source sequence  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) The function used to compare values. Default equality will be used if comparer is null.
		 function(x:TValue, y:TValue) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Filters out consecutive duplicates from a source sequence  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:expand"><apiName>expand</apiName><shortdesc>
		 
		 Recursively expands the values in the sequence using a selector function 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of all values emitted by any of the sequences
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>Accepts values and returns an expanded sequence for them:
		     function (value : T) : IObservable
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Recursively expands the values in the sequence using a selector function 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:filter"><apiName>filter</apiName><shortdesc>
		 
		 Filters out values from a source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The predicate function to execute for each value to determine if it will be include in the output
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Filters out values from a source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:finallyAction"><apiName>finallyAction</apiName><shortdesc>
		 
		 Executes a function when the sequence completes, errors or is unsubscribed from
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>action</apiItemName><apiType value="Function"/><apiDesc>The function to execute in the event the sequence completes or errors
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Executes a function when the sequence completes, errors or is unsubscribed from
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:firstOrDefault"><apiName>firstOrDefault</apiName><shortdesc>
		 
		 Emits the first value in the sequence, or a default value if the sequence completes with no values
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Emits the first value in the sequence, or a default value if the sequence completes with no values
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:first"><apiName>first</apiName><shortdesc>
		 
		 Emits the first value in the sequence, or an error if the sequence completes with no values 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Emits the first value in the sequence, or an error if the sequence completes with no values 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:forkJoin"><apiName>forkJoin</apiName><shortdesc>
		 
		 Combines the current sequence with another, emitting the last values of both after both have completed 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TResult
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to subscribe to, along with the current sequence
		 </apiDesc></apiParam><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function that accepts the last values of both sequences and returns the output value:
		     function(left : TLeft, right : TRight) : TResult 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Combines the current sequence with another, emitting the last values of both after both have completed 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:groupByUntil"><apiName>groupByUntil</apiName><shortdesc>
		 
		 Groups values by a key and also provides a lifetime for a grouping
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of IGroupedObservable
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>A selector that maps the key from a source value:
		     function(value:TValue):TKey
		 </apiDesc></apiParam><apiParam><apiItemName>durationSelector</apiItemName><apiType value="Function"/><apiDesc>A selector that returns an observable sequence that will signal 
		     the end of the life of a group by emitting a value or completing:
		     function(group:IGroupedObservable) : IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>elementSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A selector that maps the source value to the element value that 
		     will be added to the grouped items: function(value:TValue):TElement
		 </apiDesc></apiParam><apiParam><apiItemName>keyComparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>A equality comparer that compares two keys
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Groups values by a key and also provides a lifetime for a grouping
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:groupBy"><apiName>groupBy</apiName><shortdesc>
		 
		 Groups values by a key
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of IGroupedObservable
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>A selector that maps the key from a source value:
		     function(value:TValue):TKey
		 </apiDesc></apiParam><apiParam><apiItemName>elementSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A selector that maps the source value to the element value that 
		     will be added to the grouped items: function(value:TValue):TElement
		 </apiDesc></apiParam><apiParam><apiItemName>keyComparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>A equality comparer that compares two keys
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Groups values by a key
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:groupJoin"><apiName>groupJoin</apiName><shortdesc>
		 
		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 
		 selected for each value.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TResult values
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The right hand side of the join
		 </apiDesc></apiParam><apiParam><apiItemName>leftWindowSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will be called for each value from the left ("this") and will 
		     return the IObservable that represents the lifetime window of that value:
		     function(left:TLeft):IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>rightWindowSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will be called for each value from right and will 
		     return the IObservable that represents the lifetime window of that value:
		     function(right:TRight):IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>joinSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will accept "live" left/right value combinations and return a new value. 
		     The output of this function will be received by any subscribers:
		     function(left : TLeft, rights : IObservable.&lt;TRight&gt;) : TResult
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 
		 selected for each value. An IObervable set of "right" values are sent with its matching "left" value
		 to a selector to be combined. The output of this selector is emitted to the output stream  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:ignoreValues"><apiName>ignoreValues</apiName><shortdesc>
		 
		 Excludes values (calls to IObserver.onNext), emitting only onCompleted and onError 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Excludes values (calls to IObserver.onNext), emitting only onCompleted and onError 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:join"><apiName>join</apiName><shortdesc>
		 
		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 
		 selected for each value.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TResult (returned by joinSelector)
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The right hand side of the join
		 </apiDesc></apiParam><apiParam><apiItemName>leftWindowSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will be called for each value from the left ("this") and will 
		     return the IObservable that represents the lifetime window of that value:
		     function(left:TLeft):IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>rightWindowSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will be called for each value from right and will 
		     return the IObservable that represents the lifetime window of that value:
		     function(right:TRight):IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>joinSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will accept "live" left/right value combinations and return a new value. 
		     The output of this function will be received by any subscribers:
		     function(left : TLeft, right : TRight) : TResult
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 
		 selected for each value. All combinations of values from both streams that occur during this "lifetime" window 
		 are sent to a selector to be combined. The output of this selector is emitted to the output stream  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:lastOrDefault"><apiName>lastOrDefault</apiName><shortdesc>
		 
		 Emits the last value in the sequence, or the default value if the sequence completes with no values 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Emits the last value in the sequence, or the default value if the sequence completes with no values 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:last"><apiName>last</apiName><shortdesc>
		 
		 Emits the last value in the sequence, or an error if the sequence completes with no values 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Emits the last value in the sequence, or an error if the sequence completes with no values 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:let"><apiName>let</apiName><shortdesc>
		 
		 Pipes a composed sequence to be mapped through a function so it can be used multiple times 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The observable sequence returned by func 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>func</apiItemName><apiType value="Function"/><apiDesc>The function to send the current sequence through, and return a new sequence 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Pipes a composed sequence to be mapped through a function so it can be used multiple times 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:log"><apiName>log</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>message</apiItemName><apiType value="String"/></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:mapMany"><apiName>mapMany</apiName><shortdesc>
		 
		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence containing the values emitted from the child observable sequences
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The valueClass of the sequences returned by selector
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:map"><apiName>map</apiName><shortdesc>
		 
		 Maps the values from a source sequence through a function to change their value  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass result
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to be executed with each value
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Maps the values from a source sequence through a function to change their value  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:materialize"><apiName>materialize</apiName><shortdesc>
		 
		 Converts all messages (next, complete, error) into values 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of rx.Notification
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Converts all messages (next, complete, error) into values 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:mergeMany"><apiName>mergeMany</apiName><shortdesc>
		 
		 Evaluates a new sequence for each value using a selector function and merges the results 
		 of the sequence returned by the returned sequence, optionally constraining the number of 
		 concurrent sequencing.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An IObservable sequence containing the values returned
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>Accept a value of the source and returns the IObservable sequence to merge:
		     function(value:T) : IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>concurrent</apiItemName><apiType value="int"/><apiData>0</apiData></apiParam></apiOperationDef><apiDesc>
		 
		 Evaluates a new sequence for each value using a selector function and merges the results 
		 of the sequence returned by the returned sequence, optionally constraining the number of 
		 concurrent sequencing.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:merge"><apiName>merge</apiName><shortdesc>
		 
		 Emits the values from multiple sources in the order that they arrive 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The other sequences from which the values will be merged with the current sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Emits the values from multiple sources in the order that they arrive 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:multiWindow"><apiName>multiWindow</apiName><shortdesc>
		 
		 Emits values into child "window" observable sequences, which are opened and closed by the caller.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>windowOpenings</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>Signals the start of a new window by emitting a value
		 </apiDesc></apiParam><apiParam><apiItemName>windowClosingSelector</apiItemName><apiType value="Function"/><apiDesc>Returns an observable sequence that will signal the close of a window:
		 function (window : IObservable) : IObservable 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Emits values into child "window" observable sequences, which are opened and closed by the caller.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:multicastDefer"><apiName>multicastDefer</apiName><shortdesc>
		 
		 Creates a connectable sequence that can be shared by multiple observers, using a specific 
		 subject implementation (determined at subscribe-time.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence that contains messages from the selector-returned sequence, piped 
		 through the subject supplied by subjectSelector
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>subjectSelector</apiItemName><apiType value="Function"/><apiDesc>Determines the subject to be used when the sequence is subscribed to
		 </apiDesc></apiParam><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>Accepts the yet-to-be-connected connectable sequence and returns the sequence 
		 that will supply values to the subject
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Creates a connectable sequence that can be shared by multiple observers, using a specific 
		 subject implementation (determined at subscribe-time. The shared sequence will be passed 
		 to a selector function when the sequence is subscribed to.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:multicast"><apiName>multicast</apiName><shortdesc>
		 
		 Creates a connectable sequence that can be shared by multiple observers, using a specific 
		 subject implementation.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A connectable observable
		 </apiDesc><apiOperationClassifier>raix.reactive.subjects:IConnectableObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>subject</apiItemName><apiOperationClassifier>raix.reactive:ISubject</apiOperationClassifier><apiDesc>The subject that will messages and subscriptions
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Creates a connectable sequence that can be shared by multiple observers, using a specific 
		 subject implementation. 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:observeOn"><apiName>observeOn</apiName><shortdesc>
		 
		 Defers messages to subscribers through a scheduler  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiDesc>The subscriber to send messages to subscribers through
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Defers messages to subscribers through a scheduler  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:ofClass"><apiName>ofClass</apiName><shortdesc>
		 
		 Filters out values from a source sequence that are not of a specific type 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>valueClass</apiItemName><apiType value="Class"/><apiDesc>The class (or subsclass) of all values to emit 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Filters out values from a source sequence that are not of a specific type 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:onErrorResumeNext"><apiName>onErrorResumeNext</apiName><shortdesc>
		 
		 Subscribes down a list of sequence as each one errors or complete 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to run after the current sequence completes or errors
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use to subscribe to the new sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Subscribes down a list of sequence as each one errors or complete 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:peekWith"><apiName>peekWith</apiName><shortdesc>
		 
		 Allows custom code to be run when messages arrive without affecting the observer
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>observer</apiItemName><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier><apiDesc>The observer that will receive messages
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Allows custom code to be run when messages arrive without affecting the observer
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:peek"><apiName>peek</apiName><shortdesc>
		 
		 Allows custom code to be run when messages arrive without affecting the observer  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>nextAction</apiItemName><apiType value="Function"/><apiDesc>The function to execute in the event of a value (onNext)
		 </apiDesc></apiParam><apiParam><apiItemName>completeAction</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function to execute in the event the sequence completes (onComplete)
		 </apiDesc></apiParam><apiParam><apiItemName>errorAction</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function to execute in the event of an error (onError)
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Allows custom code to be run when messages arrive without affecting the observer  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:pruneDefer"><apiName>pruneDefer</apiName><shortdesc>
		 
		 Creates a shared sequence that emits the last value of the source sequence, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to map the connected sequence through
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Creates a shared sequence that emits the last value of the source sequence, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to. 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:prune"><apiName>prune</apiName><shortdesc>
		 
		 Creates a shared sequence that emits the last value of the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A connectable observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive.subjects:IConnectableObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Creates a shared sequence that emits the last value of the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:publishDefer"><apiName>publishDefer</apiName><shortdesc>
		 
		 Creates a shared sequence that can be used by multiple subscribers, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to map the connected sequence through
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Creates a shared sequence that can be used by multiple subscribers, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:publish"><apiName>publish</apiName><shortdesc>
		 
		 Creates a connectable sequence that can be shared by multiple observers  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A connectable observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive.subjects:IConnectableObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Creates a connectable sequence that can be shared by multiple observers  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:reduce"><apiName>reduce</apiName><shortdesc>
		  
		 Runs calculation functions over every value in the source sequence and emits the final result
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of type TAccumulate
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>accumulator</apiItemName><apiType value="Function"/><apiDesc>A function that accumulates the aggregate value: 
		     function(accumulate : TAccumulate, element : TElement) : TAccumulate
		 </apiDesc></apiParam><apiParam><apiItemName>initialValue</apiItemName><apiType value="Object"/><apiData>null</apiData><apiDesc>The value to start with
		 </apiDesc></apiParam><apiParam><apiItemName>useInitialValue</apiItemName><apiType value="Boolean"/><apiData>false</apiData></apiParam></apiOperationDef><apiDesc>
		  
		 Runs calculation functions over every value in the source sequence and emits the final result
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:removeTimeInterval"><apiName>removeTimeInterval</apiName><shortdesc>
		 
		 Removes time interval information added with timeInterval  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the original values (without being wrapped in TimeInterval)
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Removes time interval information added with timeInterval  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:removeTimestamp"><apiName>removeTimestamp</apiName><shortdesc>
		 
		 Removes timestamp information added with timestamp  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the original values (without being wrapped in TimeStamp)
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Removes timestamp information added with timestamp  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:repeat"><apiName>repeat</apiName><shortdesc>
		 
		 Repeats the source sequence a specific number of times 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>repeatCount</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of times to repeat the sequence or 0 to repeat indefinitely
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Repeats the source sequence a specific number of times 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:replayDefer"><apiName>replayDefer</apiName><shortdesc>
		 
		 Creates a shared sequence that replays values to future subscrubers, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to map the connected sequence through 
		 </apiDesc></apiParam><apiParam><apiItemName>bufferSize</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of values at the end of the sequence to replay, or 0 for all.
		 </apiDesc></apiParam><apiParam><apiItemName>windowMs</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The window of time, in milliseconds, in which to replay values from the end of the sequence, or 0 for all.
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Creates a shared sequence that replays values to future subscrubers, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:replay"><apiName>replay</apiName><shortdesc>
		 
		 Records the output of the source sequence and replays it to future subscribers 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A connectable observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive.subjects:IConnectableObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>bufferSize</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of values at the end of the sequence to replay, or 0 for all.
		 </apiDesc></apiParam><apiParam><apiItemName>windowMs</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The window of time, in milliseconds, in which to replay values from the end of the sequence, or 0 for all.
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Records the output of the source sequence and replays it to future subscribers 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:retry"><apiName>retry</apiName><shortdesc>
		 
		 Repeats the source sequence when an error occurs 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>retryCount</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of times to retry the sequence in the event of an error, 
		 or 0 to retry indefinitely
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Repeats the source sequence when an error occurs 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:sample"><apiName>sample</apiName><shortdesc>
		 
		 Emits the latest value on a time interval from a source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>intervalMs</apiItemName><apiType value="uint"/><apiDesc>The interval of time, in milliseconds, to sample the current value after
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Emits the latest value on a time interval from a source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:scan"><apiName>scan</apiName><shortdesc>
		 
		 Runs calculation functions over every value in the source sequence and emits the value as it is calculated 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>accumulator</apiItemName><apiType value="Function"/><apiDesc>The function that accumulates values
		 </apiDesc></apiParam><apiParam><apiItemName>initialValue</apiItemName><apiType value="Object"/><apiData>null</apiData><apiDesc>The value to start with
		 </apiDesc></apiParam><apiParam><apiItemName>useInitialValue</apiItemName><apiType value="Boolean"/><apiData>false</apiData></apiParam></apiOperationDef><apiDesc>
		 
		 Runs calculation functions over every value in the source sequence and emits the value as it is calculated 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:selectMany"><apiName>selectMany</apiName><shortdesc>
		 
		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass result
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to be executed with each value
		 </apiDesc></apiParam><apiDeprecated replacement="mapMany"/></apiOperationDef><apiDesc>
		 
		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:select"><apiName>select</apiName><shortdesc>
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/></apiParam><apiDeprecated replacement="map"/></apiOperationDef><apiDesc>
		 </apiDesc></apiOperationDetail><apiInheritDoc/></apiOperation><apiOperation id="raix.reactive:AbsObservable:sequenceEqual"><apiName>sequenceEqual</apiName><shortdesc>
		 
		 Determines whether two observable sequences are equal 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence that will emit a single boolean value once equality has been determined
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The observable sequence to compare to
		 </apiDesc></apiParam><apiParam><apiItemName>valueComparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The equality comparer to compare values between sequences:
		 function(value : TValue, otherValue : TOther) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Determines whether two observable sequences are equal 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:singleOrDefault"><apiName>singleOrDefault</apiName><shortdesc>
		 
		 Emits the only item from a source sequence, the default value if no values are emitted, or
		 an error if more than one value is emitted.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Emits the only item from a source sequence, the default value if no values are emitted, or
		 an error if more than one value is emitted.  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:single"><apiName>single</apiName><shortdesc>
		 
		 Emits the only item from a source sequence, or an error if any other number of values are emitted.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Emits the only item from a source sequence, or an error if any other number of values are emitted. 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:skipLast"><apiName>skipLast</apiName><shortdesc>
		 
		 Ignores a set number of values from the end of the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to skip from the end of the sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Ignores a set number of values from the end of the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:skipUntil"><apiName>skipUntil</apiName><shortdesc>
		 
		 Ignores values from a source sequence until a value is received from a specified sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The other sequence that will mark the start of values being used from the current sequence 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Ignores values from a source sequence until a value is received from a specified sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:skipWhile"><apiName>skipWhile</apiName><shortdesc>
		 
		 Ignores values from a source sequence until a condition is no longer met
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The function to be executed as each value is emitted. When this function returns false, values will be used from the current sequence.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Ignores values from a source sequence until a condition is no longer met
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:skip"><apiName>skip</apiName><shortdesc>
		 
		 Ignores a set number of values from the start of the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to skip from the start of the sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Ignores a set number of values from the start of the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:startWith"><apiName>startWith</apiName><shortdesc>
		 
		 Emits the specified values at the start of a sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="any"/><apiDesc>That value, converted to an IObservable using toObservable, that will 
		 be emitted at the start of the current sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Emits the specified values at the start of a sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:subscribeOn"><apiName>subscribeOn</apiName><shortdesc>
		 
		 Defers subscriptions to the source through a scheduler  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiDesc>The subscriber to schedule subscriptions through
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Defers subscriptions to the source through a scheduler  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:subscribeWith"><apiName>subscribeWith</apiName><shortdesc>
		 
		 Subscribes to this observable using the supplied observer
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An instance of ICancelable that can be used to unsubscribe at anytime by calling <codeph>cancel()</codeph> 
		 </apiDesc><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>observer</apiItemName><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
		 
		 Subscribes to this observable using the supplied observer
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:subscribe"><apiName>subscribe</apiName><shortdesc>
		 
		 Subscribes to this observable using the supplied functions 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An instance of ICancelable that can be used to unsubscribe at anytime by calling <codeph>cancel()</codeph> 
		 </apiDesc><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>onNext</apiItemName><apiType value="Function"/><apiDesc>Function to be called for every value. Signature is <codeph>function(payload : T) : void</codeph>
		 </apiDesc></apiParam><apiParam><apiItemName>onComplete</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>Optional. Function to be called when the sequence completes. Signature is <codeph>function():void</codeph>
		 </apiDesc></apiParam><apiParam><apiItemName>onError</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>Optional. Function to be called when an error occurs in the sequence. Signature is <codeph>function(err:Error):void</codeph>
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Subscribes to this observable using the supplied functions 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:sum"><apiName>sum</apiName><shortdesc>
		 
		 Returns the summed value of all the elements in the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Number
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Returns the summed value of all the elements in the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:switchMany"><apiName>switchMany</apiName><shortdesc>
		 
		 Like selectMany, starts a new sequence for every value in the source 
		 sequence but cancels the previous sequence each time.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/></apiParam></apiOperationDef><apiDesc>
		 
		 Like selectMany, starts a new sequence for every value in the source 
		 sequence but cancels the previous sequence each time.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:takeLast"><apiName>takeLast</apiName><shortdesc>
		 
		 Takes only the last set number of values from a source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to use from the end of the sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Takes only the last set number of values from a source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:takeUntil"><apiName>takeUntil</apiName><shortdesc>
		 
		 Takes values from a source sequence until a value is received from a specified sequence  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The other sequence that will mark the end of values being used from the current sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Takes values from a source sequence until a value is received from a specified sequence  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:takeWhile"><apiName>takeWhile</apiName><shortdesc>
		 
		 Takes values from a source sequence until a condition is no longer met 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The function to be executed as each value is emitted. When this function returns false, values will no longer be used from the current sequence.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Takes values from a source sequence until a condition is no longer met 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:take"><apiName>take</apiName><shortdesc>
		 
		 Takes only the first set number of values from a source sequenc
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to use from the start of the sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Takes only the first set number of values from a source sequenc
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:then"><apiName>then</apiName><shortdesc>
		 
		 Creates a Plan from this sequence, by supplying a 
		 valueClass and a mappingFunction for the values from each 
		 sequence in this Pattern 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Plan that can be used with Observable.join
		 </apiDesc><apiOperationClassifier>raix.reactive:Plan</apiOperationClassifier></apiReturn><apiParam><apiItemName>thenFunction</apiItemName><apiType value="Function"/><apiDesc>The function that will accept this sequence as an argument
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Creates a Plan from this sequence, by supplying a 
		 valueClass and a mappingFunction for the values from each 
		 sequence in this Pattern 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:throttle"><apiName>throttle</apiName><shortdesc>
		 
		 Limits how often values from a source sequence will be accepted from a source
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>dueTimeMs</apiItemName><apiType value="uint"/><apiDesc>The interval of time, in milliseconds, during which only one value from the source sequence will be accepted
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Limits how often values from a source sequence will be accepted from a source
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:timeInterval"><apiName>timeInterval</apiName><shortdesc>
		 
		 Includes, with every value emitted, the amount of time passed since the previous value 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TimeInterval
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use to determine time
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Includes, with every value emitted, the amount of time passed since the previous value 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:timeout"><apiName>timeout</apiName><shortdesc>
		 
		 Raises an error (or subscribes a specified sequence) after a certain period of inactivity 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeoutMs</apiItemName><apiType value="uint"/><apiDesc>The amount of time, in milliseconds, after which to raise an error (or subscribe to other)
		 </apiDesc></apiParam><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiData>null</apiData><apiDesc>The sequence to subscribe to in the event of a timeout. If null, a TimeoutError will be emitted.
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Raises an error (or subscribes a specified sequence) after a certain period of inactivity 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:timestamp"><apiName>timestamp</apiName><shortdesc>
		 
		 Includes, with every value emitted, the timestamp of when the value was emitted from the source 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Timestamped 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Includes, with every value emitted, the timestamp of when the value was emitted from the source 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:toArray"><apiName>toArray</apiName><shortdesc>
		 
		 Delivers all the results as a single array when the source completes 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Array that will contain the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 
		 Delivers all the results as a single array when the source completes 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:windowWithCount"><apiName>windowWithCount</apiName><shortdesc>
		 
		 Emits the values from a source sequence in groups of a specific size  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of observable sequences with the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to buffer
		 </apiDesc></apiParam><apiParam><apiItemName>skip</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of values to offset after the buffer is emitted.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Emits the values from a source sequence in groups of a specific size  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:windowWithTimeOrCount"><apiName>windowWithTimeOrCount</apiName><shortdesc>
		 
		 Emits IObservable sequences containing values received in sized batches or within a timespan, whichever occurs first
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of observable sequences with the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeMs</apiItemName><apiType value="uint"/><apiDesc>The maximum amount of time for a child-sequence to capture values
		 </apiDesc></apiParam><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The maximum amount of values for a child-sequence to capture
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 
		 Emits IObservable sequences containing values received in sized batches or within a timespan, whichever occurs first
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:windowWithTime"><apiName>windowWithTime</apiName><shortdesc>
		 
		 Emits the values from a source sequence in groups of a specific size  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of observable sequences with the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeMs</apiItemName><apiType value="uint"/><apiDesc>The amount of time to buffer before the values are released
		 </apiDesc></apiParam><apiParam><apiItemName>timeShiftMs</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The amount of time to offset after the buffer is emitted
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Emits the values from a source sequence in groups of a specific size  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:window"><apiName>window</apiName><shortdesc>
		 
		 Splits values into child-observable windows which are closed by the caller
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>windowClosingSelector</apiItemName><apiType value="Function"/><apiDesc>Returns an IObservable that will emit a value or complete to indicate that the active 
		 		  window has closed. Called on subscription and immediately after each window closes. 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Splits values into child-observable windows which are closed by the caller
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:AbsObservable:zip"><apiName>zip</apiName><shortdesc>
		 
		 Merges two sequences through a mapping function while only ever using each value once 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>rightSource</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to combine with the current
		 </apiDesc></apiParam><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to be executed when values are received from both sequences. The return value will be included in the output
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 
		 Merges two sequences through a mapping function while only ever using each value once 
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="raix.reactive:CompositeCancelable"><apiName>CompositeCancelable</apiName><shortdesc>
	 Represents a cancelable resource that controls multiple 
	 other cancelable resources 
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive:ICancelable</apiBaseInterface><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Represents a cancelable resource that controls multiple 
	 other cancelable resources 
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:CompositeCancelable:CompositeCancelable"><apiName>CompositeCancelable</apiName><shortdesc>
		 Creates a composite cancelable instance with the cancelable 
		 instances to start with
		 </shortdesc><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>values</apiItemName><apiType value="Array"/><apiData>null</apiData></apiParam></apiConstructorDef><apiDesc>
		 Creates a composite cancelable instance with the cancelable 
		 instances to start with
		 </apiDesc></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:CompositeCancelable:add"><apiName>add</apiName><shortdesc>
		 Adds a cancelable resource to the list of cancelable resources.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>cancelable</apiItemName><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
		 Adds a cancelable resource to the list of cancelable resources. If 
		 this instance has already been canceled, the resource will be immediately 
		 canceled and not added to the list.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:CompositeCancelable:cancel"><apiName>cancel</apiName><shortdesc>
		 Cancels (and removes) all resources in this instance
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 Cancels (and removes) all resources in this instance
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:CompositeCancelable:remove"><apiName>remove</apiName><shortdesc>
		 Removes a cancelable resource from the list
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>cancelable</apiItemName><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
		 Removes a cancelable resource from the list
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:CompositeCancelable:cancelables:get"><apiName>cancelables</apiName><shortdesc>
		 Gets the list of cancelable resources in this instance
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Array"/></apiValueDef><apiDesc>
		 Gets the list of cancelable resources in this instance
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:CompositeCancelable:count:get"><apiName>count</apiName><shortdesc>
		 Gets the number of resources in this list
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="uint"/></apiValueDef><apiDesc>
		 Gets the number of resources in this list
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:Subject"><apiName>Subject</apiName><shortdesc>
	 A Subject is both an IObservable and an IObserver, so it can be 
	 returned as an IObservable and fed values through the IObserver 
	 methods.</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseInterface>raix.reactive:ISubject</apiBaseInterface><apiBaseClassifier>raix.reactive:AbsObservable</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A Subject is both an IObservable and an IObserver, so it can be 
	 returned as an IObservable and fed values through the IObserver 
	 methods.
	 
	 <p>When returning a Subject as an IObservable, it's recommended that you
	 return subject.asObservable() to hide the original instance</p>
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:Subject:Subject"><apiName>Subject</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:Subject:onCompleted"><apiName>onCompleted</apiName><shortdesc>
		 
		 Notifies the subscriber that the sequence has completed and 
		 that no more messages will be received
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 
		 Notifies the subscriber that the sequence has completed and 
		 that no more messages will be received
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Subject:onError"><apiName>onError</apiName><shortdesc>
		 
		 Notifies the subscriber that the sequence has halted with an error 
		 and that no more messages will be received
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>error</apiItemName><apiType value="Error"/></apiParam></apiOperationDef><apiDesc>
		 
		 Notifies the subscriber that the sequence has halted with an error 
		 and that no more messages will be received
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Subject:onNext"><apiName>onNext</apiName><shortdesc>
		 
		 Notifies the subscriber that a value has been received
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>pl</apiItemName><apiType value="Object"/></apiParam></apiOperationDef><apiDesc>
		 
		 Notifies the subscriber that a value has been received
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Subject:subscribeWith"><apiName>subscribeWith</apiName><shortdesc>
		 
		 Subscribes to this observable using the supplied observer
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiIsOverride/><apiReturn><apiDesc>An instance of ICancelable that can be used to unsubscribe at anytime by calling <codeph>cancel()</codeph> 
		 </apiDesc><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>observer</apiItemName><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
		 
		 Subscribes to this observable using the supplied observer
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:Subject:hasSubscriptions:get"><apiName>hasSubscriptions</apiName><shortdesc>
		 Determines whether this subject has any subscriptions
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc>
		 Determines whether this subject has any subscriptions
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:Subject:subscriptionCount:get"><apiName>subscriptionCount</apiName><shortdesc>
		 Gets the number of subscriptions this subject has
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="int"/></apiValueDef><apiDesc>
		 Gets the number of subscriptions this subject has
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:Cancelable"><apiName>Cancelable</apiName><shortdesc>
	 Provides static methods that create cancelable resources
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Provides static methods that create cancelable resources
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:Cancelable:Cancelable"><apiName>Cancelable</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:Cancelable:create"><apiName>create</apiName><shortdesc>
		 Creates a cancelable resource that calls a function when canceled
		  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>action</apiItemName><apiType value="Function"/><apiDesc>The function to call when the resource is canceled 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a cancelable resource that calls a function when canceled
		  
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:Cancelable:empty:get"><apiName>empty</apiName><shortdesc>
		 Returns a cancelable resource that does nothing when canceled
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiValueClassifier>raix.reactive:ICancelable</apiValueClassifier></apiValueDef><apiDesc>
		 Returns a cancelable resource that does nothing when canceled
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:IObservable"><apiName>IObservable</apiName><shortdesc>
	 An observable (or "push"), sequence of values that often represent data or events that have not yet occured.</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 An observable (or "push"), sequence of values that often represent data or events that have not yet occured. 
	 Sequences can be manipulated, often combining them with other sequences, and then subscribed to 
	 to receive the output.
	 
	 Chains of sequences are automatically torn down when the sequence completes, errors or is unsubscribed from.
	 </apiDesc></apiClassifierDetail><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:aggregate"><apiName>aggregate</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>accumulator</apiItemName><apiType value="Function"/></apiParam><apiParam><apiItemName>initialValue</apiItemName><apiType value="Object"/><apiData>null</apiData></apiParam><apiParam><apiItemName>useInitialValue</apiItemName><apiType value="Boolean"/><apiData>false</apiData></apiParam><apiDeprecated replacement="reduce"/></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:all"><apiName>all</apiName><shortdesc>
		 Determines if all values in the source sequence satisfy a condition
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Boolean
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The predicate that determines if a value in the sequence is valid. 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Determines if all values in the source sequence satisfy a condition
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:and"><apiName>and</apiName><shortdesc> 
		 Creates a pattern by combining the current source with right.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A pattern representing both sequences
		 </apiDesc><apiOperationClassifier>raix.reactive:Pattern</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The other sequence to combine with the pattern.
		 </apiDesc></apiParam></apiOperationDef><apiDesc> 
		 Creates a pattern by combining the current source with right.
		 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:any"><apiName>any</apiName><shortdesc>
		 Determines if the source sequence contains a value that satisfies a condition
		  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Boolean
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) The predicate that determines if a value in the sequence is valid. 
		 If null, the returned sequence will emit true if the source sequence contains any values or false if it is empty.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Determines if the source sequence contains a value that satisfies a condition
		  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:asObservable"><apiName>asObservable</apiName><shortdesc>
		 Hides the source sequence so it cannot be cast back to its concrete implementation  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Hides the source sequence so it cannot be cast back to its concrete implementation  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:average"><apiName>average</apiName><shortdesc>
		 Returns the average value of all the elements in the source sequence
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TSource values
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>valueSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) The selector function that returns a numeric value from the source value  
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns the average value of all the elements in the source sequence
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:bufferWithCount"><apiName>bufferWithCount</apiName><shortdesc>
		 Emits the values from a source sequence in groups of a specific size  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of arrays of the the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to buffer
		 </apiDesc></apiParam><apiParam><apiItemName>skip</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of values to offset after the buffer is emitted.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Emits the values from a source sequence in groups of a specific size  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:bufferWithTimeOrCount"><apiName>bufferWithTimeOrCount</apiName><shortdesc>
		 Buffers values into an array, with one array for either a maximum period of time or a maximum number 
		 of values, whichever occurs first
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of observable sequences with the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeMs</apiItemName><apiType value="uint"/><apiDesc>The maximum amount of time to buffer values for
		 </apiDesc></apiParam><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The maximum amount of values to include in a single buffer
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 Buffers values into an array, with one array for either a maximum period of time or a maximum number 
		 of values, whichever occurs first
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:bufferWithTime"><apiName>bufferWithTime</apiName><shortdesc>
		 Emits the values from a source sequence in groups of a specific size  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Arrays of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeMs</apiItemName><apiType value="uint"/><apiDesc>The amount of time to buffer before the values are released
		 </apiDesc></apiParam><apiParam><apiItemName>timeShiftMs</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The amount of time to offset after the buffer is emitted
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Emits the values from a source sequence in groups of a specific size  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:cast"><apiName>cast</apiName><shortdesc>
		 Forces values from a source sequence to be of a specific class
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>valueClass</apiItemName><apiType value="Class"/><apiDesc>The valueClass of the output sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Forces values from a source sequence to be of a specific class
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:catchErrorDefer"><apiName>catchErrorDefer</apiName><shortdesc>
		 Runs a specific sequence, determined at runtime, when an error occurs
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>errorClass</apiItemName><apiType value="Class"/><apiDesc>The class (and superclass) of error to act on
		 </apiDesc></apiParam><apiParam><apiItemName>deferFunc</apiItemName><apiType value="Function"/><apiDesc>The function to execute in the event of an error. 
		 Signature is <codeph>function(e : Error) : IObservable</codeph>
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Runs a specific sequence, determined at runtime, when an error occurs
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:catchError"><apiName>catchError</apiName><shortdesc>
		 Runs a specific sequence when an error occurs
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to subscribe to when an error occurs
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Runs a specific sequence when an error occurs
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:chain"><apiName>chain</apiName><shortdesc>
		 Chains together sequences, starting with the current sequence, using selector functions that 
		 return a sequence for values of the previous.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the values returned by the sequence returned by the last 
		 selector in the chain
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>functions</apiItemName><apiType value="Array"/><apiDesc>An array of functions that accept a value from the previous sequence and 
		        return a new sequence:
		        function (value : T) : IObservable
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Chains together sequences, starting with the current sequence, using selector functions that 
		 return a sequence for values of the previous.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:combineLatest"><apiName>combineLatest</apiName><shortdesc>
		 Merges two sequences through a mapping function, using the latest value from either source 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of returnType 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to combine with
		 </apiDesc></apiParam><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function that combines values from the two sources. Signature is <codeph>function(left : this.valueClass, right : right.valueClass) : returnType</codeph>
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Merges two sequences through a mapping function, using the latest value from either source 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:concatMany"><apiName>concatMany</apiName><shortdesc>
		 Evaluates a new sequence for each value using a selector function and waits for the returned 
		 sequence to complete before resolving the next sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An IObservable sequence containing the values returned
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>Accept a value of the source and returns the IObservable sequence to concatonate:
		     function(value:T) : IObservable
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Evaluates a new sequence for each value using a selector function and waits for the returned 
		 sequence to complete before resolving the next sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:concat"><apiName>concat</apiName><shortdesc>
		 Concatonates multiple sequences by running each sequence as the previous one finishes
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequences to concatonate after the current sequence 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Concatonates multiple sequences by running each sequence as the previous one finishes
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:contains"><apiName>contains</apiName><shortdesc>
		 Determines if the source sequence contains a specific value 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Boolean
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="Object"/><apiDesc>The value to check against the sequence
		 </apiDesc></apiParam><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function used to compare values. Default equality will be used if comparer is null.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Determines if the source sequence contains a specific value 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:count"><apiName>count</apiName><shortdesc>
		 Returns the number of elements in the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of int
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Returns the number of elements in the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:delay"><apiName>delay</apiName><shortdesc>
		 Delays all values in a sequences by a specified time 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>delayMs</apiItemName><apiType value="uint"/><apiDesc>The amount of time, in milliseconds, to delay
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler used to delay the values
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Delays all values in a sequences by a specified time 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:dematerialize"><apiName>dematerialize</apiName><shortdesc>
		 Converts materialized values back into messages  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Converts materialized values back into messages  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:distinctUntilChanged"><apiName>distinctUntilChanged</apiName><shortdesc>
		 Filters out consecutive duplicates from a source sequence  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>comparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) The function used to compare values. Default equality will be used if comparer is null.
		 function(x:TValue, y:TValue) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Filters out consecutive duplicates from a source sequence  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:expand"><apiName>expand</apiName><shortdesc>
		 Recursively expands the values in the sequence using a selector function 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of all values emitted by any of the sequences
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>Accepts values and returns an expanded sequence for them:
		     function (value : T) : IObservable
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Recursively expands the values in the sequence using a selector function 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:filter"><apiName>filter</apiName><shortdesc>
		 Filters out values from a source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The predicate function to execute for each value to determine if it will be include in the output
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Filters out values from a source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:finallyAction"><apiName>finallyAction</apiName><shortdesc>
		 Executes a function when the sequence completes, errors or is unsubscribed from
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>finallyAction</apiItemName><apiType value="Function"/><apiDesc>The function to execute in the event the sequence completes or errors
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Executes a function when the sequence completes, errors or is unsubscribed from
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:firstOrDefault"><apiName>firstOrDefault</apiName><shortdesc>
		 Emits the first value in the sequence, or a default value if the sequence completes with no values
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Emits the first value in the sequence, or a default value if the sequence completes with no values
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:first"><apiName>first</apiName><shortdesc>
		 Emits the first value in the sequence, or an error if the sequence completes with no values 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Emits the first value in the sequence, or an error if the sequence completes with no values 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:forkJoin"><apiName>forkJoin</apiName><shortdesc>
		 Combines the current sequence with another, emitting the last values of both after both have completed 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TResult
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to subscribe to, along with the current sequence
		 </apiDesc></apiParam><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function that accepts the last values of both sequences and returns the output value:
		     function(left : TLeft, right : TRight) : TResult 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Combines the current sequence with another, emitting the last values of both after both have completed 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:groupByUntil"><apiName>groupByUntil</apiName><shortdesc>
		 Groups values by a key and also provides a lifetime for a grouping
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of IGroupedObservable
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>A selector that maps the key from a source value:
		     function(value:TValue):TKey
		 </apiDesc></apiParam><apiParam><apiItemName>durationSelector</apiItemName><apiType value="Function"/><apiDesc>A selector that returns an observable sequence that will signal 
		     the end of the life of a group by emitting a value or completing:
		     function(group:IGroupedObservable) : IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>elementSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A selector that maps the source value to the element value that 
		     will be added to the grouped items: function(value:TValue):TElement
		 </apiDesc></apiParam><apiParam><apiItemName>keyComparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>A equality comparer that compares two keys
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Groups values by a key and also provides a lifetime for a grouping
		 </apiDesc></apiOperationDetail><related-links><link href="raix.reactive.xml#IGroupedObservable"><linktext>raix.reactive.IGroupedObservable</linktext></link></related-links></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:groupBy"><apiName>groupBy</apiName><shortdesc>
		 Groups values by a key
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of IGroupedObservable
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>A selector that maps the key from a source value:
		     function(value:TValue):TKey
		 </apiDesc></apiParam><apiParam><apiItemName>elementSelector</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>(optional) A selector that maps the source value to the element value that 
		     will be added to the grouped items: function(value:TValue):TElement
		 </apiDesc></apiParam><apiParam><apiItemName>keyComparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>A equality comparer that compares two keys
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Groups values by a key
		 </apiDesc></apiOperationDetail><related-links><link href="raix.reactive.xml#IGroupedObservable"><linktext>raix.reactive.IGroupedObservable</linktext></link></related-links></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:groupJoin"><apiName>groupJoin</apiName><shortdesc>
		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 
		 selected for each value.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TResult values
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The right hand side of the join
		 </apiDesc></apiParam><apiParam><apiItemName>leftWindowSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will be called for each value from the left ("this") and will 
		     return the IObservable that represents the lifetime window of that value:
		     function(left:TLeft):IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>rightWindowSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will be called for each value from right and will 
		     return the IObservable that represents the lifetime window of that value:
		     function(right:TRight):IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>joinSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will accept "live" left/right value combinations and return a new value. 
		     The output of this function will be received by any subscribers:
		     function(left : TLeft, rights : IObservable.&lt;TRight&gt;) : TResult
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 
		 selected for each value. An IObervable set of "right" values are sent with its matching "left" value
		 to a selector to be combined. The output of this selector is emitted to the output stream  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:ignoreValues"><apiName>ignoreValues</apiName><shortdesc>
		 Excludes values (calls to IObserver.onNext), emitting only onCompleted and onError 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Excludes values (calls to IObserver.onNext), emitting only onCompleted and onError 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:join"><apiName>join</apiName><shortdesc>
		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 
		 selected for each value.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TResult (returned by joinSelector)
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>right</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The right hand side of the join
		 </apiDesc></apiParam><apiParam><apiItemName>leftWindowSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will be called for each value from the left ("this") and will 
		     return the IObservable that represents the lifetime window of that value:
		     function(left:TLeft):IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>rightWindowSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will be called for each value from right and will 
		     return the IObservable that represents the lifetime window of that value:
		     function(right:TRight):IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>joinSelector</apiItemName><apiType value="Function"/><apiDesc>A function that will accept "live" left/right value combinations and return a new value. 
		     The output of this function will be received by any subscribers:
		     function(left : TLeft, right : TRight) : TResult
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Combines values from two streams based on the "lifetime" of each value, represented by an IObservable 
		 selected for each value. All combinations of values from both streams that occur during this "lifetime" window 
		 are sent to a selector to be combined. The output of this selector is emitted to the output stream  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:lastOrDefault"><apiName>lastOrDefault</apiName><shortdesc>
		 Emits the last value in the sequence, or the default value if the sequence completes with no values 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Emits the last value in the sequence, or the default value if the sequence completes with no values 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:last"><apiName>last</apiName><shortdesc>
		 Emits the last value in the sequence, or an error if the sequence completes with no values 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Emits the last value in the sequence, or an error if the sequence completes with no values 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:let"><apiName>let</apiName><shortdesc>
		 Pipes a composed sequence to be mapped through a function so it can be used multiple times 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>The observable sequence returned by func 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>func</apiItemName><apiType value="Function"/><apiDesc>The function to send the current sequence through, and return a new sequence 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Pipes a composed sequence to be mapped through a function so it can be used multiple times 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:log"><apiName>log</apiName><shortdesc>
		 Writes sequence activity out to the trace log with a message describing the sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>message</apiItemName><apiType value="String"/><apiDesc>
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Writes sequence activity out to the trace log with a message describing the sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:mapMany"><apiName>mapMany</apiName><shortdesc>
		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence containing the values emitted from the child observable sequences
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The valueClass of the sequences returned by selector
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:map"><apiName>map</apiName><shortdesc>
		 Maps the values from a source sequence through a function to change their value  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass result
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to be executed with each value
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Maps the values from a source sequence through a function to change their value  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:materialize"><apiName>materialize</apiName><shortdesc>
		 Converts all messages (next, complete, error) into values 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of rx.Notification
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Converts all messages (next, complete, error) into values 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:mergeMany"><apiName>mergeMany</apiName><shortdesc>
		 Evaluates a new sequence for each value using a selector function and merges the results 
		 of the sequence returned by the returned sequence, optionally constraining the number of 
		 concurrent sequencing.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An IObservable sequence containing the values returned
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>Accept a value of the source and returns the IObservable sequence to merge:
		     function(value:T) : IObservable
		 </apiDesc></apiParam><apiParam><apiItemName>concurrent</apiItemName><apiType value="int"/><apiData>0</apiData></apiParam></apiOperationDef><apiDesc>
		 Evaluates a new sequence for each value using a selector function and merges the results 
		 of the sequence returned by the returned sequence, optionally constraining the number of 
		 concurrent sequencing.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:merge"><apiName>merge</apiName><shortdesc>
		 Emits the values from multiple sources in the order that they arrive 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The other sequences from which the values will be merged with the current sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Emits the values from multiple sources in the order that they arrive 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:multiWindow"><apiName>multiWindow</apiName><shortdesc>
		 Emits values into child "window" observable sequences, which are opened and closed by the caller.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>windowOpenings</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>Signals the start of a new window by emitting a value
		 </apiDesc></apiParam><apiParam><apiItemName>windowClosingSelector</apiItemName><apiType value="Function"/><apiDesc>Returns an observable sequence that will signal the close of a window:
		 function (window : IObservable) : IObservable 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Emits values into child "window" observable sequences, which are opened and closed by the caller.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:multicastDefer"><apiName>multicastDefer</apiName><shortdesc>
		 Creates a connectable sequence that can be shared by multiple observers, using a specific 
		 subject implementation (determined at subscribe-time.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence that contains messages from the selector-returned sequence, piped 
		 through the subject supplied by subjectSelector
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>subjectSelector</apiItemName><apiType value="Function"/><apiDesc>Determines the subject to be used when the sequence is subscribed to
		 </apiDesc></apiParam><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>Accepts the yet-to-be-connected connectable sequence and returns the sequence 
		 that will supply values to the subject
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a connectable sequence that can be shared by multiple observers, using a specific 
		 subject implementation (determined at subscribe-time. The shared sequence will be passed 
		 to a selector function when the sequence is subscribed to.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:multicast"><apiName>multicast</apiName><shortdesc>
		 Creates a connectable sequence that can be shared by multiple observers, using a specific 
		 subject implementation.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A connectable observable
		 </apiDesc><apiOperationClassifier>raix.reactive.subjects:IConnectableObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>subject</apiItemName><apiOperationClassifier>raix.reactive:ISubject</apiOperationClassifier><apiDesc>The subject that will messages and subscriptions
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a connectable sequence that can be shared by multiple observers, using a specific 
		 subject implementation. 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:observeOn"><apiName>observeOn</apiName><shortdesc>
		 Defers messages to subscribers through a scheduler  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiDesc>The subscriber to send messages to subscribers through
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Defers messages to subscribers through a scheduler  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:ofClass"><apiName>ofClass</apiName><shortdesc>
		 Filters out values from a source sequence that are not of a specific type 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>valueClass</apiItemName><apiType value="Class"/><apiDesc>The class (or subsclass) of all values to emit 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Filters out values from a source sequence that are not of a specific type 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:onErrorResumeNext"><apiName>onErrorResumeNext</apiName><shortdesc>
		 Subscribes down a list of sequence as each one errors or complete 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>second</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to run after the current sequence completes or errors
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use to subscribe to the new sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Subscribes down a list of sequence as each one errors or complete 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:peekWith"><apiName>peekWith</apiName><shortdesc>
		 Allows custom code to be run when messages arrive without affecting the observer
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>observer</apiItemName><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier><apiDesc>The observer that will receive messages
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Allows custom code to be run when messages arrive without affecting the observer
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:peek"><apiName>peek</apiName><shortdesc>
		 Allows custom code to be run when messages arrive without affecting the observer  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>next</apiItemName><apiType value="Function"/><apiDesc>The function to execute in the event of a value (onNext)
		 </apiDesc></apiParam><apiParam><apiItemName>complete</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function to execute in the event the sequence completes (onComplete)
		 </apiDesc></apiParam><apiParam><apiItemName>error</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function to execute in the event of an error (onError)
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Allows custom code to be run when messages arrive without affecting the observer  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:pruneDefer"><apiName>pruneDefer</apiName><shortdesc>
		 Creates a shared sequence that emits the last value of the source sequence, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to map the connected sequence through
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a shared sequence that emits the last value of the source sequence, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to. 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:prune"><apiName>prune</apiName><shortdesc>
		 Creates a shared sequence that emits the last value of the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A connectable observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive.subjects:IConnectableObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a shared sequence that emits the last value of the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:publishDefer"><apiName>publishDefer</apiName><shortdesc>
		 Creates a shared sequence that can be used by multiple subscribers, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to map the connected sequence through
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a shared sequence that can be used by multiple subscribers, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:publish"><apiName>publish</apiName><shortdesc>
		 Creates a connectable sequence that can be shared by multiple observers  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A connectable observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive.subjects:IConnectableObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Creates a connectable sequence that can be shared by multiple observers  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:reduce"><apiName>reduce</apiName><shortdesc> 
		 Runs calculation functions over every value in the source sequence and emits the final result
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of type TAccumulate
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>accumulator</apiItemName><apiType value="Function"/><apiDesc>A function that accumulates the aggregate value: 
		     function(accumulate : TAccumulate, element : TElement) : TAccumulate
		 </apiDesc></apiParam><apiParam><apiItemName>initialValue</apiItemName><apiType value="Object"/><apiData>null</apiData><apiDesc>The value to start with
		 </apiDesc></apiParam><apiParam><apiItemName>useInitialValue</apiItemName><apiType value="Boolean"/><apiData>false</apiData></apiParam></apiOperationDef><apiDesc> 
		 Runs calculation functions over every value in the source sequence and emits the final result
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:removeTimeInterval"><apiName>removeTimeInterval</apiName><shortdesc>
		 Removes time interval information added with timeInterval  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the original values (without being wrapped in TimeInterval)
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Removes time interval information added with timeInterval  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:removeTimestamp"><apiName>removeTimestamp</apiName><shortdesc>
		 Removes timestamp information added with timestamp  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the original values (without being wrapped in TimeStamp)
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Removes timestamp information added with timestamp  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:repeat"><apiName>repeat</apiName><shortdesc>
		 Repeats the source sequence a specific number of times 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>repeatCount</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of times to repeat the sequence or 0 to repeat indefinitely
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Repeats the source sequence a specific number of times 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:replayDefer"><apiName>replayDefer</apiName><shortdesc>
		 Creates a shared sequence that replays values to future subscrubers, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to map the connected sequence through 
		 </apiDesc></apiParam><apiParam><apiItemName>bufferSize</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of values at the end of the sequence to replay, or 0 for all.
		 </apiDesc></apiParam><apiParam><apiItemName>windowMs</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The window of time, in milliseconds, in which to replay values from the end of the sequence, or 0 for all.
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a shared sequence that replays values to future subscrubers, the shared 
		 sequence will be passed to the selector function when the sequence is subscribed to
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:replay"><apiName>replay</apiName><shortdesc>
		 Records the output of the source sequence and replays it to future subscribers 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A connectable observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive.subjects:IConnectableObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>bufferSize</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of values at the end of the sequence to replay, or 0 for all.
		 </apiDesc></apiParam><apiParam><apiItemName>windowMs</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The window of time, in milliseconds, in which to replay values from the end of the sequence, or 0 for all.
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Records the output of the source sequence and replays it to future subscribers 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:retry"><apiName>retry</apiName><shortdesc>
		 Repeats the source sequence when an error occurs 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>retryCount</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of times to retry the sequence in the event of an error, 
		 or 0 to retry indefinitely
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Repeats the source sequence when an error occurs 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:sample"><apiName>sample</apiName><shortdesc>
		 Emits the latest value on a time interval from a source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>intervalMs</apiItemName><apiType value="uint"/><apiDesc>The interval of time, in milliseconds, to sample the current value after
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Emits the latest value on a time interval from a source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:scan"><apiName>scan</apiName><shortdesc>
		 Runs calculation functions over every value in the source sequence and emits the value as it is calculated 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>accumulator</apiItemName><apiType value="Function"/><apiDesc>The function that accumulates values
		 </apiDesc></apiParam><apiParam><apiItemName>initialValue</apiItemName><apiType value="Object"/><apiData>null</apiData><apiDesc>The value to start with
		 </apiDesc></apiParam><apiParam><apiItemName>useInitialValue</apiItemName><apiType value="Boolean"/><apiData>false</apiData></apiParam></apiOperationDef><apiDesc>
		 Runs calculation functions over every value in the source sequence and emits the value as it is calculated 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:selectMany"><apiName>selectMany</apiName><shortdesc>
		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass result
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to be executed with each value
		 </apiDesc></apiParam><apiDeprecated replacement="mapMany"/></apiOperationDef><apiDesc>
		 Starts a new sequence, returned by selector, for every value in the source sequence and merges their values
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:sequenceEqual"><apiName>sequenceEqual</apiName><shortdesc>
		 Determines whether two observable sequences are equal 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence that will emit a single boolean value once equality has been determined
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The observable sequence to compare to
		 </apiDesc></apiParam><apiParam><apiItemName>valueComparer</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The equality comparer to compare values between sequences:
		 function(value : TValue, otherValue : TOther) : Boolean
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Determines whether two observable sequences are equal 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:singleOrDefault"><apiName>singleOrDefault</apiName><shortdesc>
		 Emits the only item from a source sequence, the default value if no values are emitted, or
		 an error if more than one value is emitted.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Emits the only item from a source sequence, the default value if no values are emitted, or
		 an error if more than one value is emitted.  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:single"><apiName>single</apiName><shortdesc>
		 Emits the only item from a source sequence, or an error if any other number of values are emitted.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Emits the only item from a source sequence, or an error if any other number of values are emitted. 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:skipLast"><apiName>skipLast</apiName><shortdesc>
		 Ignores a set number of values from the end of the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to skip from the end of the sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Ignores a set number of values from the end of the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:skipUntil"><apiName>skipUntil</apiName><shortdesc>
		 Ignores values from a source sequence until a value is received from a specified sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The other sequence that will mark the start of values being used from the current sequence 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Ignores values from a source sequence until a value is received from a specified sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:skipWhile"><apiName>skipWhile</apiName><shortdesc>
		 Ignores values from a source sequence until a condition is no longer met
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The function to be executed as each value is emitted. When this function returns false, values will be used from the current sequence.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Ignores values from a source sequence until a condition is no longer met
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:skip"><apiName>skip</apiName><shortdesc>
		 Ignores a set number of values from the start of the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to skip from the start of the sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Ignores a set number of values from the start of the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:startWith"><apiName>startWith</apiName><shortdesc>
		 Emits the specified values at the start of a sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="any"/><apiDesc>That value, converted to an IObservable using toObservable, that will 
		 be emitted at the start of the current sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Emits the specified values at the start of a sequence 
		 </apiDesc></apiOperationDetail><related-links><link href="" invalidHref="raix.reactive.toObservable.xml"><linktext>raix.reactive.toObservable</linktext></link></related-links></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:subscribeOn"><apiName>subscribeOn</apiName><shortdesc>
		 Defers subscriptions to the source through a scheduler  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiDesc>The subscriber to schedule subscriptions through
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Defers subscriptions to the source through a scheduler  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:subscribeWith"><apiName>subscribeWith</apiName><shortdesc>
		 Subscribes to this observable using the supplied observer
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An instance of ICancelable that can be used to unsubscribe at anytime by calling <codeph>cancel()</codeph> 
		 </apiDesc><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>observer</apiItemName><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
		 Subscribes to this observable using the supplied observer
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:subscribe"><apiName>subscribe</apiName><shortdesc>
		 Subscribes to this observable using the supplied functions 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An instance of ICancelable that can be used to unsubscribe at anytime by calling <codeph>cancel()</codeph> 
		 </apiDesc><apiOperationClassifier>raix.reactive:ICancelable</apiOperationClassifier></apiReturn><apiParam><apiItemName>onNext</apiItemName><apiType value="Function"/><apiDesc>Function to be called for every value. Signature is <codeph>function(payload : T) : void</codeph>
		 </apiDesc></apiParam><apiParam><apiItemName>onComplete</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>Optional. Function to be called when the sequence completes. Signature is <codeph>function():void</codeph>
		 </apiDesc></apiParam><apiParam><apiItemName>onError</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>Optional. Function to be called when an error occurs in the sequence. Signature is <codeph>function(err:Error):void</codeph>
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Subscribes to this observable using the supplied functions 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:sum"><apiName>sum</apiName><shortdesc>
		 Returns the summed value of all the elements in the source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Number
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Returns the summed value of all the elements in the source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:switchMany"><apiName>switchMany</apiName><shortdesc>
		 Like selectMany, starts a new sequence for every value in the source 
		 sequence but cancels the previous sequence each time.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/></apiParam></apiOperationDef><apiDesc>
		 Like selectMany, starts a new sequence for every value in the source 
		 sequence but cancels the previous sequence each time.
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:takeLast"><apiName>takeLast</apiName><shortdesc>
		 Takes only the last set number of values from a source sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to use from the end of the sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Takes only the last set number of values from a source sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:takeUntil"><apiName>takeUntil</apiName><shortdesc>
		 Takes values from a source sequence until a value is received from a specified sequence  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The other sequence that will mark the end of values being used from the current sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Takes values from a source sequence until a value is received from a specified sequence  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:takeWhile"><apiName>takeWhile</apiName><shortdesc>
		 Takes values from a source sequence until a condition is no longer met 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The function to be executed as each value is emitted. When this function returns false, values will no longer be used from the current sequence.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Takes values from a source sequence until a condition is no longer met 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:take"><apiName>take</apiName><shortdesc>
		 Takes only the first set number of values from a source sequenc
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to use from the start of the sequence
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Takes only the first set number of values from a source sequenc
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:then"><apiName>then</apiName><shortdesc>
		 Creates a Plan from this sequence, by supplying a 
		 valueClass and a mappingFunction for the values from each 
		 sequence in this Pattern 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Plan that can be used with Observable.join
		 </apiDesc><apiOperationClassifier>raix.reactive:Plan</apiOperationClassifier></apiReturn><apiParam><apiItemName>thenFunction</apiItemName><apiType value="Function"/><apiDesc>The function that will accept this sequence as an argument
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a Plan from this sequence, by supplying a 
		 valueClass and a mappingFunction for the values from each 
		 sequence in this Pattern 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:throttle"><apiName>throttle</apiName><shortdesc>
		 Limits how often values from a source sequence will be accepted from a source
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>dueTimeMs</apiItemName><apiType value="uint"/><apiDesc>The interval of time, in milliseconds, during which only one value from the source sequence will be accepted
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Limits how often values from a source sequence will be accepted from a source
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:timeInterval"><apiName>timeInterval</apiName><shortdesc>
		 Includes, with every value emitted, the amount of time passed since the previous value 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of TimeInterval
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use to determine time
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Includes, with every value emitted, the amount of time passed since the previous value 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:timeout"><apiName>timeout</apiName><shortdesc>
		 Raises an error (or subscribes a specified sequence) after a certain period of inactivity 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeoutMs</apiItemName><apiType value="uint"/><apiDesc>The amount of time, in milliseconds, after which to raise an error (or subscribe to other)
		 </apiDesc></apiParam><apiParam><apiItemName>other</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiData>null</apiData><apiDesc>The sequence to subscribe to in the event of a timeout. If null, a TimeoutError will be emitted.
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Raises an error (or subscribes a specified sequence) after a certain period of inactivity 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:timestamp"><apiName>timestamp</apiName><shortdesc>
		 Includes, with every value emitted, the timestamp of when the value was emitted from the source 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Timestamped 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Includes, with every value emitted, the timestamp of when the value was emitted from the source 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:toArray"><apiName>toArray</apiName><shortdesc>
		 Delivers all the results as a single array when the source completes 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of Array that will contain the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Delivers all the results as a single array when the source completes 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:windowWithCount"><apiName>windowWithCount</apiName><shortdesc>
		 Emits the values from a source sequence in groups of a specific size  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of observable sequences with the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values to buffer
		 </apiDesc></apiParam><apiParam><apiItemName>skip</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of values to offset after the buffer is emitted.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Emits the values from a source sequence in groups of a specific size  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:windowWithTimeOrCount"><apiName>windowWithTimeOrCount</apiName><shortdesc>
		 Emits IObservable sequences containing values received in sized batches or within a timespan, whichever occurs first
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of observable sequences with the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeMs</apiItemName><apiType value="uint"/><apiDesc>The maximum amount of time for a child-sequence to capture values
		 </apiDesc></apiParam><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The maximum amount of values for a child-sequence to capture
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 Emits IObservable sequences containing values received in sized batches or within a timespan, whichever occurs first
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:windowWithTime"><apiName>windowWithTime</apiName><shortdesc>
		 Emits the values from a source sequence in groups of a specific size  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of observable sequences with the same type as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>timeMs</apiItemName><apiType value="uint"/><apiDesc>The amount of time to buffer before the values are released
		 </apiDesc></apiParam><apiParam><apiItemName>timeShiftMs</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The amount of time to offset after the buffer is emitted
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Emits the values from a source sequence in groups of a specific size  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:window"><apiName>window</apiName><shortdesc>
		 Splits values into child-observable windows which are closed by the caller
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of the same valueClass as the current sequence
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>windowClosingSelector</apiItemName><apiType value="Function"/><apiDesc>Returns an IObservable that will emit a value or complete to indicate that the active 
		 		  window has closed. Called on subscription and immediately after each window closes. 
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Splits values into child-observable windows which are closed by the caller
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObservable:raix.reactive:IObservable:zip"><apiName>zip</apiName><shortdesc>
		 Merges two sequences through a mapping function while only ever using each value once 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>rightSource</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to combine with the current
		 </apiDesc></apiParam><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/><apiDesc>The function to be executed when values are received from both sequences. The return value will be included in the output
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Merges two sequences through a mapping function while only ever using each value once 
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="raix.reactive:Notification"><apiName>Notification</apiName><shortdesc>
	 Represents one of the three messages that can be sent to 
	 an observer.</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Represents one of the three messages that can be sent to 
	 an observer.
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="" invalidHref="rx.OnNext.xml"><linktext>rx.OnNext</linktext></link><link href="" invalidHref="rx.OnCompleted.xml"><linktext>rx.OnCompleted</linktext></link><link href="" invalidHref="rx.OnError.xml"><linktext>rx.OnError</linktext></link></related-links><apiConstructor id="raix.reactive:Notification:Notification"><apiName>Notification</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:Notification:acceptWith"><apiName>acceptWith</apiName><shortdesc>
		 Calls the appropriate method on an observer
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>observer</apiItemName><apiOperationClassifier>raix.reactive:IObserver</apiOperationClassifier></apiParam></apiOperationDef><apiDesc>
		 Calls the appropriate method on an observer
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Notification:accept"><apiName>accept</apiName><shortdesc>
		 Calls the appropriate method
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>onNext</apiItemName><apiType value="Function"/></apiParam><apiParam><apiItemName>onCompleted</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam><apiParam><apiItemName>onError</apiItemName><apiType value="Function"/><apiData>null</apiData></apiParam></apiOperationDef><apiDesc>
		 Calls the appropriate method
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:Notification:error:get"><apiName>error</apiName><shortdesc>
		 Gets the error associated with this message or null if there is no error.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Error"/></apiValueDef><apiDesc>
		 Gets the error associated with this message or null if there is no error.
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:Notification:hasValue:get"><apiName>hasValue</apiName><shortdesc>
		 Determined whether this instance has a value property available
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Boolean"/></apiValueDef><apiDesc>
		 Determined whether this instance has a value property available
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:Notification:kind:get"><apiName>kind</apiName><shortdesc>
		 Gets the NotificationKind of this instance
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="int"/></apiValueDef><apiDesc>
		 Gets the NotificationKind of this instance
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:Notification:value:get"><apiName>value</apiName><shortdesc>
		 Gets the value associated with this message
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Object"/></apiValueDef><apiDesc>
		 Gets the value associated with this message
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:Observable"><apiName>Observable</apiName><shortdesc>
	 Provides static methods that create IObservable sequences
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Provides static methods that create IObservable sequences
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:Observable:Observable"><apiName>Observable</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:Observable:amb"><apiName>amb</apiName><shortdesc>
		 Takes multiple source sequences and returns values from the first sequence to emit a value  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of the same valueClass as the first sequence in sources
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>sources</apiItemName><apiType value="Array"/><apiDesc>The sources that will be subscribed to
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Takes multiple source sequences and returns values from the first sequence to emit a value  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:catchErrors"><apiName>catchErrors</apiName><shortdesc>
		 Concatonates a list of sequences as each one errors.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence with the valueClass of the first sequence in sources
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>sources</apiItemName><apiType value="Array"/><apiDesc>The list of sequence to concatonate.
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler used to control flow
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Concatonates a list of sequences as each one errors. A successful sequence ends the concatonation.  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:concat"><apiName>concat</apiName><shortdesc>
		 Concatonates multiple sequences by running each sequence as the previous one finishes 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>sources</apiItemName><apiType value="any"/><apiDesc>Anything that can be converted to an IObservable of IObservables using toObservable
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Concatonates multiple sequences by running each sequence as the previous one finishes 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:createWithCancelable"><apiName>createWithCancelable</apiName><shortdesc>
		 Creates a custom observable sequence that uses cancelable resources  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>subscribeFunc</apiItemName><apiType value="Function"/><apiDesc>The function that will be executed when a subscriber subscribes, the return value of which is an ICancelable to be canceled when the sequence is terminated
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a custom observable sequence that uses cancelable resources  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:create"><apiName>create</apiName><shortdesc>
		 Creates a custom observable sequence  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>subscribeFunc</apiItemName><apiType value="Function"/><apiDesc>The function that will be executed when a subscriber subscribes, the return value of which is a function to be run when the sequence is terminated
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a custom observable sequence  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:defer"><apiName>defer</apiName><shortdesc>
		 Defers selection of a sequence until the sequence is subscribed to  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>observableFactory</apiItemName><apiType value="Function"/><apiDesc>The function that will be executed when a new subscription occurs, the returned sequence will be used for the subscriber.
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Defers selection of a sequence until the sequence is subscribed to  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:empty"><apiName>empty</apiName><shortdesc>
		 Creates a sequence that immediately completes  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence that immediately completes  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:error"><apiName>error</apiName><shortdesc>
		 Creates a sequence that immediately throws an Error  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>err</apiItemName><apiType value="Error"/><apiDesc>The error to raise when a new subscription occurs
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence that immediately throws an Error  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:forkJoin"><apiName>forkJoin</apiName><shortdesc>
		 Subscribes to multiple source sequence and emits the last values of each after all have completed 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of Array
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>sources</apiItemName><apiType value="Array"/><apiDesc>The sequences to subscribe to
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Subscribes to multiple source sequence and emits the last values of each after all have completed 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:fromArray"><apiName>fromArray</apiName><shortdesc>
		 Creates a sequence consisting of the values in an Array 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of elementClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>values</apiItemName><apiType value="Array"/><apiDesc>The array of values to iterate through
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler used to control flow
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence consisting of the values in an Array 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:fromErrorEvents"><apiName>fromErrorEvents</apiName><shortdesc>
		 Creates a sequence that emits an error when one of several event valueClasss is received from an IEventDispatcher
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>eventDispatcher</apiItemName><apiType value="flash.events:IEventDispatcher"/><apiDesc>The IEventDispatcher that dispatches the event
		 </apiDesc></apiParam><apiParam><apiItemName>eventTypes</apiItemName><apiType value="Array"/><apiDesc>The event types that signify an error
		 </apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiType value="Boolean"/><apiData>false</apiData><apiDesc>Whether to pass useCapture when subscribing to and unsubscribing from the event
		 </apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiType value="int"/><apiData>0</apiData><apiDesc>The priority of the event
		 </apiDesc></apiParam><apiParam><apiItemName>errorMap</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function that maps an event to an Error. null can be used if the event will be ErrorEvent
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence that emits an error when one of several event valueClasss is received from an IEventDispatcher
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:fromErrorEvent"><apiName>fromErrorEvent</apiName><shortdesc>
		 Creates a sequence that emits an error when an event is received from an IEventDispatcher  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass, or Object if valueClass is null 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>eventDispatcher</apiItemName><apiType value="flash.events:IEventDispatcher"/><apiDesc>The IEventDispatcher that dispatches the event
		 </apiDesc></apiParam><apiParam><apiItemName>eventType</apiItemName><apiType value="String"/><apiDesc>The event type
		 </apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiType value="Boolean"/><apiData>false</apiData><apiDesc>Whether to pass useCapture when subscribing to and unsubscribing from the event
		 </apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiType value="int"/><apiData>0</apiData><apiDesc>The priority of the event
		 </apiDesc></apiParam><apiParam><apiItemName>errorMap</apiItemName><apiType value="Function"/><apiData>null</apiData><apiDesc>The function that maps an event to an Error. null can be used if the event will be ErrorEvent
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence that emits an error when an event is received from an IEventDispatcher  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:fromEvents"><apiName>fromEvents</apiName><shortdesc>
		 Creates Combines events from multiple event valueClasss 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of commonValueClass, or Event if commonValueClass is null 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>eventDispatcher</apiItemName><apiType value="flash.events:IEventDispatcher"/><apiDesc>The IEventDispatcher that dispatches the event
		 </apiDesc></apiParam><apiParam><apiItemName>eventTypes</apiItemName><apiType value="Array"/><apiDesc>An array event type names
		 </apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiType value="Boolean"/><apiData>false</apiData><apiDesc>Whether to pass useCapture when subscribing to and unsubscribing from the event
		 </apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiType value="int"/><apiData>0</apiData><apiDesc>The priority of the event
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates Combines events from multiple event valueClasss 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:fromEvent"><apiName>fromEvent</apiName><shortdesc>
		 Creates a sequence of events from an IEventDispatcher 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of eventType, or Event if eventType is null
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>eventDispatcher</apiItemName><apiType value="flash.events:IEventDispatcher"/><apiDesc>The IEventDispatcher that dispatches the event
		 </apiDesc></apiParam><apiParam><apiItemName>eventType</apiItemName><apiType value="String"/><apiDesc>The valueClass of event dispatched by eventDispatcher. Event will be used if this argument is null.
		 </apiDesc></apiParam><apiParam><apiItemName>useCapture</apiItemName><apiType value="Boolean"/><apiData>false</apiData><apiDesc>Whether to pass useCapture when subscribing to and unsubscribing from the event
		 </apiDesc></apiParam><apiParam><apiItemName>priority</apiItemName><apiType value="int"/><apiData>0</apiData><apiDesc>The priority of the event
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence of events from an IEventDispatcher 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:generate"><apiName>generate</apiName><shortdesc>
		 Creates a custom observable sequence that is controlled by methods supplied as arguments 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>initialState</apiItemName><apiType value="Object"/><apiDesc>The initial state value to use (of class valueClass)
		 </apiDesc></apiParam><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The predicate to determine whether the sequence has completed
		 </apiDesc></apiParam><apiParam><apiItemName>iterate</apiItemName><apiType value="Function"/><apiDesc>The function executed between iterations
		 </apiDesc></apiParam><apiParam><apiItemName>resultMap</apiItemName><apiType value="Function"/><apiDesc>The function that maps the current state to an output value
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler used to control flow
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a custom observable sequence that is controlled by methods supplied as arguments 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:ifElse"><apiName>ifElse</apiName><shortdesc>
		 Defers selection of one of two sequences until the sequence is subscribed to
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>predicate</apiItemName><apiType value="Function"/><apiDesc>The function to execute when a subscription occurs to determine which sequence to subscribe to
		 </apiDesc></apiParam><apiParam><apiItemName>ifTrue</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to subscribe to if predicate returns true
		 </apiDesc></apiParam><apiParam><apiItemName>ifFalse</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The sequence to subscribe to if predicate returns false
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Defers selection of one of two sequences until the sequence is subscribed to
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:interval"><apiName>interval</apiName><shortdesc>
		 Creates an unending observable sequence of integers that are incremented at a regular interval 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of int
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>intervalMs</apiItemName><apiType value="uint"/><apiDesc>The interval, in milliseconds, to wait in between values
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler used for timing
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates an unending observable sequence of integers that are incremented at a regular interval 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:lookup"><apiName>lookup</apiName><shortdesc>
		 Defers selection of the sequence to use by using a function that returns a key into a dictionary of sequences 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>keySelector</apiItemName><apiType value="Function"/><apiDesc>The function that, at the moment of subscription, will return the key into dictionary
		 </apiDesc></apiParam><apiParam><apiItemName>dictionary</apiItemName><apiType value="flash.utils:Dictionary"/><apiDesc>The dictionary of sequences
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Defers selection of the sequence to use by using a function that returns a key into a dictionary of sequences 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:merge"><apiName>merge</apiName><shortdesc>
		 Emits the values from multiple sources in the order that they arrive 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>sources</apiItemName><apiType value="any"/><apiDesc>Either an array of IObservable or an IObservable of IObservables
		 </apiDesc></apiParam><apiParam><apiItemName>concurrent</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The scheduler used to control flow
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Emits the values from multiple sources in the order that they arrive 
		 </apiDesc></apiOperationDetail><related-links><link href="" invalidHref="raix.reactive.toObservable.xml"><linktext>raix.reactive.toObservable</linktext></link></related-links></apiOperation><apiOperation id="raix.reactive:Observable:never"><apiName>never</apiName><shortdesc>
		 Returns an IObservable that never completes
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn></apiOperationDef><apiDesc>
		 Returns an IObservable that never completes
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:onErrorResumeNext"><apiName>onErrorResumeNext</apiName><shortdesc>
		 Concatonates a list of sequence as each one errors or complete 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of the valueClass of the value sequence in sources
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>sources</apiItemName><apiType value="Array"/><apiDesc>The list of sequences to concatonate
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Concatonates a list of sequence as each one errors or complete 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:range"><apiName>range</apiName><shortdesc>
		 Creates a sequence of consecutive integers  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of int
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>start</apiItemName><apiType value="int"/><apiDesc>The inclusive start value of the range
		 </apiDesc></apiParam><apiParam><apiItemName>count</apiItemName><apiType value="uint"/><apiDesc>The number of values, including start, to emit
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence of consecutive integers  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:repeatValue"><apiName>repeatValue</apiName><shortdesc>
		 Repeats a value a specification number of times 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiType value="Object"/><apiDesc>The value to repeat
		 </apiDesc></apiParam><apiParam><apiItemName>repeatCount</apiItemName><apiType value="uint"/><apiData>0</apiData><apiDesc>The number of times to emit the value
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Repeats a value a specification number of times 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:start"><apiName>start</apiName><shortdesc>
		 Creates a sequence based on a call to a function  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>action</apiItemName><apiType value="Function"/><apiDesc>The function to call
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a sequence based on a call to a function  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:timer"><apiName>timer</apiName><shortdesc>
		 Creates an unending observable sequence of integers that begin after a delay and are incremented at a regular interval 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of int
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>delayMs</apiItemName><apiType value="uint"/><apiDesc>The interval, in milliseconds, to wait before the first value
		 </apiDesc></apiParam><apiParam><apiItemName>intervalMs</apiItemName><apiType value="uint"/><apiDesc>The interval, in milliseconds, to wait in between subsequent values
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler used for timing
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates an unending observable sequence of integers that begin after a delay and are incremented at a regular interval 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:toAsync"><apiName>toAsync</apiName><shortdesc>
		 Converts a function into an observable sequence  
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>A function accepting the arguments of the original action, but that will 
		 return an IObservable when called.
		 </apiDesc><apiType value="Function"/></apiReturn><apiParam><apiItemName>action</apiItemName><apiType value="Function"/><apiDesc>The function to call
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Converts a function into an observable sequence  
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:uncaughtErrors"><apiName>uncaughtErrors</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>loaderInfo</apiItemName><apiType value="flash.display:LoaderInfo"/><apiData>null</apiData></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:urlLoader"><apiName>urlLoader</apiName><shortdesc>
		 Creates an observable sequence that loads an object from a URLRequest 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of Object
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>request</apiItemName><apiType value="flash.net:URLRequest"/><apiDesc>The URLRequest to load
		 </apiDesc></apiParam><apiParam><apiItemName>dataFormat</apiItemName><apiType value="String"/><apiData>text</apiData><apiDesc>A value of flash.net.URLLoaderDataFormat
		 </apiDesc></apiParam><apiParam><apiItemName>loaderContext</apiItemName><apiType value="flash.system:LoaderContext"/><apiData>null</apiData><apiDesc>The optional LoaderContext to use
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates an observable sequence that loads an object from a URLRequest 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:value"><apiName>value</apiName><shortdesc>
		 Create a sequence consisting of exactly one value 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>val</apiItemName><apiType value="Object"/><apiDesc>The value to emit
		 </apiDesc></apiParam><apiParam><apiItemName>scheduler</apiItemName><apiOperationClassifier>raix.reactive.scheduling:IScheduler</apiOperationClassifier><apiData>null</apiData><apiDesc>The scheduler to use to control flow
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Create a sequence consisting of exactly one value 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:when"><apiName>when</apiName><shortdesc>
		 Matches multiple plans (source sequence combinations) in the order they are specified 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An observable sequence of valueClass
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>plans</apiItemName><apiType value="Array"/><apiDesc>The array of rx.Plan objects creates using 'and' and 'then'
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Matches multiple plans (source sequence combinations) in the order they are specified 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Observable:xml"><apiName>xml</apiName><shortdesc>
		 Loads an XML document
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>An IObservable sequence of XMLDocument 
		 </apiDesc><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>request</apiItemName><apiType value="flash.net:URLRequest"/><apiDesc>The URLRequest to load
		 </apiDesc></apiParam><apiParam><apiItemName>loaderContext</apiItemName><apiType value="flash.system:LoaderContext"/><apiData>null</apiData><apiDesc>Whether to ignore whitespace when parsing the XML
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Loads an XML document
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.reactive:Observable:maxConcurrentLoaders:get"><apiName>maxConcurrentLoaders</apiName><shortdesc>
		 Gets the maximum number of urlLoaders that can execute concurrently.</shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="readwrite"/><apiType value="uint"/></apiValueDef><apiDesc>
		 Gets the maximum number of urlLoaders that can execute concurrently. The value 
		 defaults to 2 to prevent issues in some browers. 
		 </apiDesc></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.reactive:ICancelable"><apiName>ICancelable</apiName><shortdesc>
	 Represents a handle that can be used to cancel an operation 
	 
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 Represents a handle that can be used to cancel an operation 
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="" invalidHref="raix.reactive.CompositeCancelable,.xml"><linktext>raix.reactive.BooleanCancelable, raix.reactive.FutureCancelable, raix.reactive.Cancelable</linktext></link></related-links><apiOperation id="raix.reactive:ICancelable:raix.reactive:ICancelable:cancel"><apiName>cancel</apiName><shortdesc>
		 Cancels the operation
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 Cancels the operation
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="raix.reactive:NotificationKind"><apiName>NotificationKind</apiName><shortdesc>
	 Enumeration for the different types of Notification
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Enumeration for the different types of Notification
	 </apiDesc></apiClassifierDetail><apiValue id="raix.reactive:NotificationKind:ON_COMPLETED"><apiName>ON_COMPLETED</apiName><shortdesc>
		 An onCompleted message
		 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>2</apiData><apiType value="int"/></apiValueDef><apiDesc>
		 An onCompleted message
		 
		 </apiDesc></apiValueDetail><related-links><link href="" invalidHref="rx.OnCompleted.xml"><linktext>rx.OnCompleted</linktext></link></related-links></apiValue><apiValue id="raix.reactive:NotificationKind:ON_ERROR"><apiName>ON_ERROR</apiName><shortdesc>
		 An onError message
		 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>1</apiData><apiType value="int"/></apiValueDef><apiDesc>
		 An onError message
		 
		 </apiDesc></apiValueDetail><related-links><link href="" invalidHref="rx.OnError.xml"><linktext>rx.OnError</linktext></link></related-links></apiValue><apiValue id="raix.reactive:NotificationKind:ON_NEXT"><apiName>ON_NEXT</apiName><shortdesc>
		 An onNext (value) message
		 
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiAccess value="public"/><apiStatic/><apiData>0</apiData><apiType value="int"/></apiValueDef><apiDesc>
		 An onNext (value) message
		 
		 </apiDesc></apiValueDetail><related-links><link href="" invalidHref="rx.OnNext.xml"><linktext>rx.OnNext</linktext></link></related-links></apiValue></apiClassifier><apiOperation id="globalOperation:raix.reactive:toObservable"><apiName>toObservable</apiName><shortdesc>
	 Converts a value to an IObservable sequence.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier></apiReturn><apiParam><apiItemName>args</apiItemName><apiType value="restParam"/></apiParam></apiOperationDef><apiDesc>
	 Converts a value to an IObservable sequence. It can be considered to have the following overloads:
	 
	 <ul>
	 <li>function():IObservable - returns an empty sequence</li>
	 <li>function(array : Array):Observable - returns a sequence that wraps an array</li>
	 <li>function(observable : IObservable):IObservable - returns observable</li>
	 <li>function(enumerable : IEnumerable):IObservable - returns a sequence that wraps eumerable</li>
	 <li>function(error : Error):IObservable - returns a sequence will error when subscribed to</li>
	 <li>function(value : :IEnumerable - returns enumerable that contains a single value</li>
	 </ul>
	 </apiDesc></apiOperationDetail></apiOperation><apiClassifier id="raix.reactive:Pattern"><apiName>Pattern</apiName><shortdesc>
	 A combination of multiple IObservable sequences that can be combined 
	 into a Plan
	 
	 Generally, a Pattern will be created using IObservable.and or 
	 Pattern.and(), rather than creating a Pattern directly
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A combination of multiple IObservable sequences that can be combined 
	 into a Plan
	 
	 <p>Generally, a Pattern will be created using IObservable.and or 
	 Pattern.and(), rather than creating a Pattern directly</p>
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:Pattern:Pattern"><apiName>Pattern</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>sources</apiItemName><apiType value="Array"/></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiOperation id="raix.reactive:Pattern:and"><apiName>and</apiName><shortdesc>
		 Creates another pattern that combines the IObservable sequences 
		 of this Pattern with another IObservable sequence 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Pattern with the new set of sequences
		 
		 </apiDesc><apiOperationClassifier>raix.reactive:Pattern</apiOperationClassifier></apiReturn><apiParam><apiItemName>source</apiItemName><apiOperationClassifier>raix.reactive:IObservable</apiOperationClassifier><apiDesc>The IObservable sequence to add
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates another pattern that combines the IObservable sequences 
		 of this Pattern with another IObservable sequence 
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:Pattern:then"><apiName>then</apiName><shortdesc>
		 Creates a Plan from this Pattern, by supplying a 
		 valueClass and a mappingFunction for the values from each 
		 sequence in this Pattern 
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiDesc>A Plan that can be used with Observable.when
		 </apiDesc><apiOperationClassifier>raix.reactive:Plan</apiOperationClassifier></apiReturn><apiParam><apiItemName>thenFunction</apiItemName><apiType value="Function"/><apiDesc>The valueClass that will be returned by thenFunction
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Creates a Plan from this Pattern, by supplying a 
		 valueClass and a mappingFunction for the values from each 
		 sequence in this Pattern 
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="raix.reactive:IObserver"><apiName>IObserver</apiName><shortdesc>
	 An object that receives messages from an IObservable sequence
	 
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiInterface/><apiAccess value="public"/><apiStatic/><apiBaseClassifier/></apiClassifierDef><apiDesc>
	 An object that receives messages from an IObservable sequence
	 
	 </apiDesc></apiClassifierDetail><related-links><link href="raix.reactive.xml#Observer"><linktext>Observer</linktext></link></related-links><apiOperation id="raix.reactive:IObserver:raix.reactive:IObserver:onCompleted"><apiName>onCompleted</apiName><shortdesc>
		 Notifies the subscriber that the sequence has completed and 
		 that no more messages will be received
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn></apiOperationDef><apiDesc>
		 Notifies the subscriber that the sequence has completed and 
		 that no more messages will be received
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObserver:raix.reactive:IObserver:onError"><apiName>onError</apiName><shortdesc>
		 Notifies the subscriber that the sequence has halted with an error 
		 and that no more messages will be received
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>error</apiItemName><apiType value="Error"/></apiParam></apiOperationDef><apiDesc>
		 Notifies the subscriber that the sequence has halted with an error 
		 and that no more messages will be received
		 </apiDesc></apiOperationDetail></apiOperation><apiOperation id="raix.reactive:IObserver:raix.reactive:IObserver:onNext"><apiName>onNext</apiName><shortdesc>
		 Notifies the subscriber that a value has been received
		 </shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiReturn><apiType value="void"/></apiReturn><apiParam><apiItemName>value</apiItemName><apiType value="Object"/></apiParam></apiOperationDef><apiDesc>
		 Notifies the subscriber that a value has been received
		 </apiDesc></apiOperationDetail></apiOperation></apiClassifier><apiClassifier id="raix.reactive:Plan"><apiName>Plan</apiName><shortdesc>
	 A combination of IObservable sequences and a selector that will 
	 map the values of those sequences to an output value.</shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 A combination of IObservable sequences and a selector that will 
	 map the values of those sequences to an output value. A plan is intended 
	 to be used with Observable.when
	 
	 <p>Generally, a Plan will be created using Pattern.then(), rather 
	 than creating a Plan directly</p>
	 </apiDesc></apiClassifierDetail><apiConstructor id="raix.reactive:Plan:Plan"><apiName>Plan</apiName><shortdesc/><prolog/><apiConstructorDetail><apiConstructorDef><apiAccess value="public"/><apiParam><apiItemName>sources</apiItemName><apiType value="Array"/></apiParam><apiParam><apiItemName>selector</apiItemName><apiType value="Function"/></apiParam></apiConstructorDef></apiConstructorDetail></apiConstructor><apiValue id="raix.reactive:Plan:selector:get"><apiName>selector</apiName><shortdesc>
		 Gets the function selector that will accept one argument for each 
		 sequence in sources and return the output value
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Function"/></apiValueDef><apiDesc>
		 Gets the function selector that will accept one argument for each 
		 sequence in sources and return the output value
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.reactive:Plan:sources:get"><apiName>sources</apiName><shortdesc>
		 Gets the observable sequences in this plan
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiDynamic/><apiValueAccess value="read"/><apiType value="Array"/></apiValueDef><apiDesc>
		 Gets the observable sequences in this plan
		 </apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage><apiPackage id="raix.utils"><apiName>raix.utils</apiName><apiDetail/><apiClassifier id="raix.utils:Filter"><apiName>Filter</apiName><shortdesc/><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef></apiClassifierDetail><apiOperation id="raix.utils:Filter:not"><apiName>not</apiName><shortdesc/><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiType value="Function"/></apiReturn><apiParam><apiItemName>inner</apiItemName><apiType value="Function"/></apiParam></apiOperationDef></apiOperationDetail></apiOperation><apiValue id="raix.utils:Filter:notNull:get"><apiName>notNull</apiName><shortdesc/><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiType value="Function"/></apiValueDef></apiValueDetail></apiValue></apiClassifier><apiClassifier id="raix.utils:Projection"><apiName>Projection</apiName><shortdesc>
	 Contains common projection functions that can be used with IEnumerable.map 
	 and other 
	 </shortdesc><prolog><asMetadata/></prolog><apiClassifierDetail><apiClassifierDef><apiAccess value="public"/><apiStatic/><apiBaseClassifier>Object</apiBaseClassifier></apiClassifierDef><apiDesc>
	 Contains common projection functions that can be used with IEnumerable.map 
	 and other 
	 </apiDesc></apiClassifierDetail><apiOperation id="raix.utils:Projection:property"><apiName>property</apiName><shortdesc>
		 Returns a selector function that retrieves a property from an element.</shortdesc><prolog/><apiOperationDetail><apiOperationDef><apiAccess value="public"/><apiStatic/><apiReturn><apiDesc>A function that returns the property value of propertyName or null if the element was null
		 </apiDesc><apiType value="Function"/></apiReturn><apiParam><apiItemName>propertyName</apiItemName><apiType value="String"/><apiDesc>The property to map from each element
		 </apiDesc></apiParam></apiOperationDef><apiDesc>
		 Returns a selector function that retrieves a property from an element. 
		 </apiDesc></apiOperationDetail></apiOperation><apiValue id="raix.utils:Projection:toLowerCase:get"><apiName>toLowerCase</apiName><shortdesc>
		 Returns a selector function that converts a string to lower case
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiType value="Function"/></apiValueDef><apiDesc>
		 Returns a selector function that converts a string to lower case
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.utils:Projection:toString:get"><apiName>toString</apiName><shortdesc>
		 Returns a selector function that converts an object to a string
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiType value="Function"/></apiValueDef><apiDesc>
		 Returns a selector function that converts an object to a string
		 </apiDesc></apiValueDetail></apiValue><apiValue id="raix.utils:Projection:toUpperCase:get"><apiName>toUpperCase</apiName><shortdesc>
		 Returns a selector function that converts a string to upper case
		 </shortdesc><prolog/><apiValueDetail><apiValueDef><apiProperty/><apiAccess value="public"/><apiStatic/><apiValueAccess value="read"/><apiType value="Function"/></apiValueDef><apiDesc>
		 Returns a selector function that converts a string to upper case
		 </apiDesc></apiValueDetail></apiValue></apiClassifier></apiPackage></allClasses>